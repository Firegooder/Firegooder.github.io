<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从0学Linux驱动 | huzayn's blog</title><meta name="author" content="huzayn"><meta name="copyright" content="huzayn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="嵌入式linux驱动本文主要参考b站up主：一口Linux HELLOWORLD驱动编写程序编写步骤：  确定主设备号 定义自己的 file operations结构体 实现对应的 open&#x2F;read&#x2F;write等函数，填入file_operations 结构体 把 file operations结构体告诉内核:注册驱动程序 谁来注册驱动程序啊?得有一个入口函数:安装驱动程序时">
<meta property="og:type" content="article">
<meta property="og:title" content="从0学Linux驱动">
<meta property="og:url" content="http://example.com/2025/12/25/%E4%BB%8E0%E5%AD%A6Linux%E9%A9%B1%E5%8A%A8/index.html">
<meta property="og:site_name" content="huzayn&#39;s blog">
<meta property="og:description" content="嵌入式linux驱动本文主要参考b站up主：一口Linux HELLOWORLD驱动编写程序编写步骤：  确定主设备号 定义自己的 file operations结构体 实现对应的 open&#x2F;read&#x2F;write等函数，填入file_operations 结构体 把 file operations结构体告诉内核:注册驱动程序 谁来注册驱动程序啊?得有一个入口函数:安装驱动程序时">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/logo.png">
<meta property="article:published_time" content="2025-12-25T11:46:26.000Z">
<meta property="article:modified_time" content="2025-12-25T12:16:49.457Z">
<meta property="article:author" content="huzayn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "从0学Linux驱动",
  "url": "http://example.com/2025/12/25/%E4%BB%8E0%E5%AD%A6Linux%E9%A9%B1%E5%8A%A8/",
  "image": "http://example.com/img/logo.png",
  "datePublished": "2025-12-25T11:46:26.000Z",
  "dateModified": "2025-12-25T12:16:49.457Z",
  "author": [
    {
      "@type": "Person",
      "name": "huzayn",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/logo.png"><link rel="canonical" href="http://example.com/2025/12/25/%E4%BB%8E0%E5%AD%A6Linux%E9%A9%B1%E5%8A%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从0学Linux驱动',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/20250104-P1021765.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/P1054693_lab.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/logo.png" alt="Logo"><span class="site-name">huzayn's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">从0学Linux驱动</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">从0学Linux驱动</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-25T11:46:26.000Z" title="发表于 2025-12-25 19:46:26">2025-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-25T12:16:49.457Z" title="更新于 2025-12-25 20:16:49">2025-12-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="嵌入式linux驱动"><a href="#嵌入式linux驱动" class="headerlink" title="嵌入式linux驱动"></a>嵌入式linux驱动</h1><p>本文主要参考b站up主：一口Linux</p>
<h2 id="HELLOWORLD驱动编写"><a href="#HELLOWORLD驱动编写" class="headerlink" title="HELLOWORLD驱动编写"></a>HELLOWORLD驱动编写</h2><p>程序编写步骤：</p>
<ol>
<li>确定主设备号</li>
<li>定义自己的 file operations结构体</li>
<li>实现对应的 open&#x2F;read&#x2F;write等函数，填入file_operations 结构体</li>
<li>把 file operations结构体告诉内核:注册驱动程序</li>
<li>谁来注册驱动程序啊?得有一个入口函数:安装驱动程序时，就会去调用这个入口函数</li>
<li>有入口函数就应该有出口函数:卸载驱动程序时，就会去调用这个出口函数</li>
<li>其他完善:提供设备信息，自动创建设备节点</li>
</ol>
<p>设备号：主设备号+次设备号 函数：<code>MKDEV（a,b）</code>可返回设备号，a为主设备号，b为次设备号</p>
<p><code>rc = alloc_chrdev_region(&amp;devid, 0, 1, &quot;hello&quot;); </code> 用于分配设备号，主设备号由内核动态分配，此设备号由自己设计</p>
<p>，该代码中次设备号从0开始，共1个设备号，名称为hello。</p>
<h3 id="在ubantu虚拟机中跑驱动程序"><a href="#在ubantu虚拟机中跑驱动程序" class="headerlink" title="在ubantu虚拟机中跑驱动程序"></a>在ubantu虚拟机中跑驱动程序</h3><p>用echo指令确保架构设置和没有交叉编译，使用 unset ARCH  和  unset CROSS_COMPILE确保在x86架构下 ,写好程序后，使用 su root或者 su -进入超级用户模式，此处和教程不一样，我安装的设备只能由root用户读写。建议使用su root，因为这样可以继续保留当前文件路径，而su -会回到起始路径<img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250828160849152.png"></p>
<ul>
<li>make</li>
<li>ls 查看</li>
<li>insmod hello_drv.ko 安装驱动</li>
<li>lsmod 查看驱动，ls &#x2F;dev&#x2F;hello -l 驱动会生成设备节点，该操作查看设备节点</li>
<li>gcc -o hello_drv_test hello_drv_test.c  编译应用程序（测试文件）</li>
<li>.&#x2F;hello_drv_test 运行应用程序</li>
<li>.&#x2F;hello_drv_test -w huuu，写操作</li>
<li>sudo .&#x2F;hello_drv_test -r 读操作</li>
<li>sudo rmmod hello_drv 移除驱动</li>
</ul>
<h2 id="LED驱动程序-驱动设计思想"><a href="#LED驱动程序-驱动设计思想" class="headerlink" title="LED驱动程序(驱动设计思想)"></a>LED驱动程序(驱动设计思想)</h2><p>hello驱动不涉及硬件操作，而led则需要硬件操作，因此可以写一个没有具体硬件的模版，把驱动拆分为通用的框架(leddrv.c)、具体的硬件操作(board_X.c)  </p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250903143657641.png" alt="image-20250903143657641"></p>
<p>韦东山在led_init函数中使用了<code>major = register_chrdev(0, &quot;led&quot;, &amp;led_fops)</code>;来注册驱动，而在hello驱动中使用了<code>alloc_chrdev_region</code> 动态分配</p>
<p>寄存器的值不能被优化，因此要使用<code>volatile</code>。如果是软件要执行a &#x3D; 1,a&#x3D;2；那么可以直接把a赋值为2，但是对于 <code>int *p = addr</code>,想让<code>*p=1,*p=2</code>,不能直接优化为<code>*p=2</code>,如1是点灯，2是灭灯，直接优化会导致无亮灯过程，而<code>volatile</code>易变的意思，让编译器不要优化变量</p>
<p>寄存器地址虚拟映射：</p>
<figure class="highlight plaintext"><figcaption><span>ioremap */</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x14</span><br><span class="line">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(0x02290000 + 0x14, 4);</span><br><span class="line"></span><br><span class="line">// GPIO5_GDIR 地址：0x020AC004</span><br><span class="line">GPIO5_GDIR = ioremap(0x020AC004, 4);</span><br><span class="line"></span><br><span class="line">//GPIO5_DR 地址：0x020AC000</span><br><span class="line">GPIO5_DR  = ioremap(0x020AC000, 4);</span><br><span class="line"></span><br><span class="line">led_class = class_create(THIS_MODULE, &quot;myled&quot;);</span><br><span class="line">device_create(led_class, NULL, MKDEV(major, 0), NULL, &quot;myled&quot;); /* /dev/myled */</span><br></pre></td></tr></table></figure>

<p><code>ioremap</code>和<code>iounmap</code></p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250904150320599.png" alt="image-20250904150320599"><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250904150342270.png" alt="image-20250904150342270"></p>
<h2 id="符号导出"><a href="#符号导出" class="headerlink" title="符号导出"></a>符号导出</h2><h3 id="KERN-SON"><a href="#KERN-SON" class="headerlink" title="KERN_SON"></a>KERN_SON</h3><ol>
<li>KERN_SOH可以设置打印级别</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kernel\include\linux\kern_levels.h</span><br><span class="line"> </span><br><span class="line">#define KERN_EMERG	KERN_SOH &quot;0&quot;	/* system is unusable */</span><br><span class="line">#define KERN_ALERT	KERN_SOH &quot;1&quot;	/* action must be taken immediately */</span><br><span class="line">#define KERN_CRIT	KERN_SOH &quot;2&quot;	/* critical conditions */</span><br><span class="line">#define KERN_ERR	KERN_SOH &quot;3&quot;	/* error conditions */</span><br><span class="line">#define KERN_WARNING	KERN_SOH &quot;4&quot;	/* warning conditions */</span><br><span class="line">#define KERN_NOTICE	KERN_SOH &quot;5&quot;	/* normal but significant condition */</span><br><span class="line">#define KERN_INFO	KERN_SOH &quot;6&quot;	/* informational */</span><br><span class="line">#define KERN_DEBUG	KERN_SOH &quot;7&quot;	/* debug-level messages */</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>查看当前printk打印消息的log等级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/sys/kernel/printk</span><br><span class="line">7       4       1       7</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何修改打印等级</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在驱动中使用：</span><br><span class="line">printk(KERN_INFO &quot;Driver initialized\n&quot;);</span><br><span class="line">printk(KERN_ERR &quot;Failed to map registers\n&quot;);</span><br><span class="line">printk(KERN_DEBUG &quot;GPIO value: %d\n&quot;, gpio_value);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="符号导出-1"><a href="#符号导出-1" class="headerlink" title="符号导出"></a>符号导出</h3><p>这里的符号主要指的是全局变量和函数<br>Linux内核采用的是以模块化形式管理内核代码。内核中的每个模块相互之间是相互独立的，也就是说A模块的全局变量和函数，B模块是无法访问的。</p>
<p>符号表位置：</p>
<p>Ubuntu中<br>Linux内核的全局符号表在&#x2F;usr&#x2F;src&#x2F;linux-headers-xxxxx-generic-pae&#x2F;Module.symvers<br>某个单独编译的内核·根目录下</p>
<p>打开上述Module.symvers文件，依次为：标号、地址、全局变量或函数名称、地址、通信方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CRC&gt; &lt;Symbol&gt; &lt;Module&gt; &lt;Export Type&gt;</span><br></pre></td></tr></table></figure>

<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910110239500.png" alt="image-20250910110239500"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910111735347.png" alt="image-20250910111735347"></p>
<ol>
<li><p>编译模块A,然后加载模块A,在模块A编译好后，在它的当前目录会看到一个Module.symvers文件，这里存放的就是我们模块A导出的符号。</p>
</li>
<li><p>将模块A编译生成的Module.symvers文件拷贝到模块B目录下，然后编译模块B，先加载A模块，,加载模块B。</p>
</li>
<li><p>通过dmesg查看模块打印的信息,</p>
</li>
<li><p>卸载：先卸载B，再卸载A。</p>
</li>
</ol>
<h2 id="模块传参"><a href="#模块传参" class="headerlink" title="模块传参"></a>模块传参</h2><p>它让你可以在加载模块时（使用 <code>insmod</code>或 <code>modmodprobe</code>）动态地给模块内的变量赋值，而无需修改源代码并重新编译。</p>
<p>其中一个典型函数：</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910142041758.png" alt="image-20250910142041758"></p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910142421962.png" alt="image-20250910142421962"></p>
<p>其他原型：字符串、数组、描述(description)</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910142532974.png" alt="image-20250910142532974"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_param_named(var_out,var,int0644);//重命名，在驱动代码内定义了var，在终端调用时，使用var_out</span><br></pre></td></tr></table></figure>

<p>perm定义了模块加载后，在 <code>/sys/module/&lt;你的模块名&gt;/parameters/</code>目录下生成的参数文件的访问权限</p>
<p>perm常用值：0644</p>
<ul>
<li><p><strong>第一个数字 <code>0</code></strong>：代表<strong>特殊权限位</strong>（如 setuid, setgid, sticky bit）。在这里是 <code>0</code>，表示不设置任何特殊权限。</p>
</li>
<li><p>•</p>
<p><strong>第二个数字 <code>6</code></strong>：代表<strong>文件所有者（owner）</strong> 的权限。</p>
</li>
<li><p>•</p>
<p><strong>第三个数字 <code>4</code></strong>：代表<strong>文件所属组（group）</strong> 的权限。</p>
</li>
<li><p>•</p>
<p><strong>第四个数字 <code>4</code></strong>：代表<strong>其他所有用户（others）</strong> 的权限。</p>
</li>
</ul>
<p>这些数字是由 <code>r</code>（读，值为4）、<code>w</code>（写，值为2）、<code>x</code>（执行，值为1）相加得到的：</p>
<table>
<thead>
<tr>
<th align="center">数字</th>
<th align="center">计算</th>
<th align="center">权限</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>6</strong></td>
<td align="center">4 (r) + 2 (w) + 0 (x)</td>
<td align="center"><code>rw-</code></td>
<td align="center">所有者可<strong>读</strong>、可<strong>写</strong></td>
</tr>
<tr>
<td align="center"><strong>4</strong></td>
<td align="center">4 (r) + 0 (w) + 0 (x)</td>
<td align="center"><code>r--</code></td>
<td align="center">组用户仅可<strong>读</strong></td>
</tr>
<tr>
<td align="center"><strong>4</strong></td>
<td align="center">4 (r) + 0 (w) + 0 (x)</td>
<td align="center"><code>r--</code></td>
<td align="center">其他用户仅可<strong>读</strong></td>
</tr>
</tbody></table>
<p>所以，<code>0644</code>表示：</p>
<ul>
<li><p>•</p>
<p><strong>文件所有者（通常是root）</strong>：可以<strong>读取</strong>和<strong>修改</strong>这个参数文件（例如 <code>echo 1 &gt; /sys/.../parameter</code>）。</p>
</li>
<li><p>•</p>
<p><strong>同组用户和其他所有用户</strong>：只能<strong>读取</strong>这个参数文件的值（例如 <code>cat /sys/.../parameter</code>）。</p>
<h3 id="其他常见权限值示例"><a href="#其他常见权限值示例" class="headerlink" title="其他常见权限值示例"></a>其他常见权限值示例</h3><ul>
<li><code>S_IRUGO</code>(等同于 <code>0444</code>)：<strong>只读</strong>（所有者、组、其他用户都只有读权限）。</li>
<li><code>S_IWUSR | S_IRUGO</code>(等同于 <code>0644</code>)：<strong>root可读写，其他用户只读</strong>（这就是你图片中的情况，也是最常用的配置）。</li>
<li><code>S_IWUSR | S_IRUSR</code>(等同于 <code>0600</code>)：<strong>仅root用户可读可写</strong>，其他用户无任何权限（更安全）。</li>
<li><code>0</code>：<strong>完全不在sysfs中创建文件</strong>。参数只能通过 <code>insmod</code>命令行设置，运行时无法查看或修改。</li>
</ul>
<p>如何修改模块参数：在安装mod时为参数赋值</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250925100744019.png" alt="image-20250925100744019"></p>
<p>更正统的做法是使用DEVICE_ATTR</p>
</li>
</ul>
<h3 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h3><p><code>sysfs</code>是一个位于内存中的<strong>虚拟文件系统</strong>。它由内核提供，将内核内部的数据结构、对象、它们的属性和关系，以文件和目录的形式导出到用户空间。</p>
<p>你可以通过挂载点 <code>/sys</code>来访问它</p>
<p>在<code>sys/module</code>下可以查看mudule，比如hello模块</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910152534978.png" alt="image-20250910152534978"></p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910153331531.png" alt="image-20250910153331531"></p>
<h2 id="字符设备号"><a href="#字符设备号" class="headerlink" title="字符设备号"></a>字符设备号</h2><p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910200852865.png" alt="image-20250910200852865"></p>
<p>设备号是无符号整型值，高12位：主设备号，低20位：次设备号</p>
<p>查看设备号：cat &#x2F;proc&#x2F;devices</p>
<p>以下三个函数可以用来查看和创建设备号</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910203655042.png" alt="image-20250910203655042"></p>
<p>注册设备号(静态）：<code>int register_chrdev_region(dev_t from, unsigned count, const char *name)</code></p>
<p>注册设备号（动态）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, const char *name)</span><br><span class="line">•dev：输出参数。内核会把分配到的第一个设备号放在这里。</span><br><span class="line">•firstminor：你希望的起始次设备号，通常设为0。</span><br><span class="line">•count：要申请的设备号数量。</span><br><span class="line">•name：设备名。</span><br></pre></td></tr></table></figure>

<p>注销设备号：<code>void unregister_chrdev_region(dev_t from, unsigned count)</code></p>
<h2 id="字符设备架构"><a href="#字符设备架构" class="headerlink" title="字符设备架构"></a>字符设备架构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct char_device_struct &#123;</span><br><span class="line">	struct char_device_struct *next;</span><br><span class="line">	unsigned int major;</span><br><span class="line">	unsigned int baseminor;</span><br><span class="line">	int minorct;</span><br><span class="line">	char name[64];</span><br><span class="line">	struct cdev *cdev;		/* will die */</span><br><span class="line">&#125; *chrdevs[CHRDEV_MAJOR_HASH_SIZE];</span><br></pre></td></tr></table></figure>

<p>Cdev成员</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250910203655042.png" alt="image-20250910203655042"></p>
<p>把自己设备所需要的操作填充到file_operations结构体</p>
<p>问：用户层如何找到内核态的驱动？</p>
<p>答：在用户态中mknod 操作（如mknod &#x2F;dev&#x2F;hello c 237 0）可以实现创建文件节点，文件节点的设备号存在于VFS中， 在VFS（虚拟文件系统）中Inode 存储了每个文件的静态信息，比如创建时间、读写权限等，该结构体里面包含一个变量 dev_t i_rdev 也就是设备号，通过该设备号可以找到内核态的chrdevs，char_device_struct结构体，在此结构体里面有cdev结构体，继而找到file_operations，实现读写操作。</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\d83012e0-3fbc-4e3d-9544-a8090c1cce12.png" alt="d83012e0-3fbc-4e3d-9544-a8090c1cce12"></p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\d05ab4b9-554d-4af4-8fe7-d488a20caff3.png" alt="d05ab4b9-554d-4af4-8fe7-d488a20caff3"></p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\ad0a27ad-1fcf-4765-a603-f619cf43ec25.png" alt="ad0a27ad-1fcf-4765-a603-f619cf43ec25"></p>
<p>当注册了驱动之后，f_ops就会对应到struct file中，当使用系统函数open、write时，比如在用户测试文件中调用open，此时会直接通过vfs中的struct file来找到f_ops，而不是走上面说的左边那一条路径</p>
<p> <img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\f68580a4-5fd9-4818-af27-3789af527b12.png" alt="f68580a4-5fd9-4818-af27-3789af527b12"></p>
<p>连续open 两次同样的文件，文件描述符fd也会不同 </p>
<h3 id="字符设备注册"><a href="#字符设备注册" class="headerlink" title="字符设备注册"></a>字符设备注册</h3><p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\f6be4407-ade5-4c9e-ae0a-964974459903.png" alt="f6be4407-ade5-4c9e-ae0a-964974459903"></p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250923095202069.png" alt="image-20250923095202069"></p>
<p>内核里面有很多kobject开头的函数，属于系统架构函数，可以不用搞懂</p>
<h2 id="字符设备注册–更简单的方式"><a href="#字符设备注册–更简单的方式" class="headerlink" title="字符设备注册–更简单的方式"></a>字符设备注册–更简单的方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int __register_chrdev(unsigned int major, unsigned int baseminor,</span><br><span class="line">		      unsigned int count, const char *name,</span><br><span class="line">		      const struct file_operations *fops)</span><br><span class="line">/​**​</span><br><span class="line">__register_chrdev() - 创建并注册一个占用连续次设备号范围的字符设备(cdev)</span><br><span class="line">@major: 主设备号，若为0则表示请求动态分配</span><br><span class="line">@baseminor: 请求的次设备号范围的起始编号</span><br><span class="line">@count: 需要申请的次设备号数量</span><br><span class="line">@name: 该设备范围的名称</span><br><span class="line">@fops: 与此设备关联的文件操作结构</span><br><span class="line">如果 @major == 0，本函数将自动动态分配一个主设备号并返回其数值。</span><br><span class="line">如果 @major &gt; 0，本函数将尝试预留指定主设备号，成功时返回零。</span><br><span class="line">失败时返回负的错误码。</span><br><span class="line"></span><br><span class="line">void __unregister_chrdev(unsigned int major, unsigned int baseminor,</span><br><span class="line">			 unsigned int count, const char *name)</span><br><span class="line">&#123;</span><br><span class="line">	struct char_device_struct *cd;</span><br><span class="line"></span><br><span class="line">	cd = __unregister_chrdev_region(major, baseminor, count);</span><br><span class="line">	if (cd &amp;&amp; cd-&gt;cdev)</span><br><span class="line">		cdev_del(cd-&gt;cdev);</span><br><span class="line">	kfree(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250923142451365.png" alt="image-20250923142451365"></p>
<h2 id="字符设备ioctl接口"><a href="#字符设备ioctl接口" class="headerlink" title="字符设备ioctl接口"></a>字符设备ioctl接口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line"></span><br><span class="line">int ioctl(int fd, unsigned long cmd, ...);</span><br></pre></td></tr></table></figure>

<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250924095714302.png" alt="image-20250924095714302"></p>
<p>内核里面的函数原型：在file_operations结构体中也使用unlocked_ioctl</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250924100656358.png" alt="image-20250924100656358"></p>
<p>调用关系：</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250924101050848.png" alt="image-20250924101050848"></p>
<p>cmd如何填充：</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250924101238316.png" alt="image-20250924101238316"></p>
<p>这些cmd都在内核里面宏定义了，直接拿来用就可以</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250924103358487.png" alt="image-20250924103358487"></p>
<p>注意，序号不要和已有的冲突</p>
<p>如何检查命令、地址正确性 ?<br>	可以通过宏 IOC TYPE(nr)来判断应用程序传下来的命令type是否正确;<br>	可以通过宏 IOC DIR(nr)来得到命令是读还是写，然后再通过宏access_ok(type,addrsize)来判断用户层传递的内存地址是否合法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (_IOC_TYPE(cmd) != DEV_FIFO_TYPE) &#123;</span><br><span class="line">    pr_err(&quot;cmd %u, bad magic 0x%x/0x%x.\n&quot;, cmd, _IOC_TYPE(cmd), DEV_FIFO_TYPE);</span><br><span class="line">    return -ENOTTY;</span><br><span class="line">&#125;</span><br><span class="line">if (_IOC_DIR(cmd) &amp; _IOC_READ)</span><br><span class="line">    ret = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line">else if (_IOC_DIR(cmd) &amp; _IOC_WRITE)</span><br><span class="line">    ret = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">    pr_err(&quot;bad access %ld.\n&quot;, ret);</span><br><span class="line">    return -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>常通过switch语句来使用ioctl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static long my_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">    switch (cmd) &#123;</span><br><span class="line">    case MY_DEVICE_SET_BRIGHTNESS:</span><br><span class="line">        /* arg 被解释为一个整数 */</span><br><span class="line">        int brightness = (int)arg;</span><br><span class="line">        // ... 设置硬件的亮度 ...</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case MY_DEVICE_GET_CONFIG:</span><br><span class="line">        /* arg 被解释为一个指向用户空间内存的指针 */</span><br><span class="line">        struct my_config user_config;</span><br><span class="line">        // ... 准备数据到 user_config ...</span><br><span class="line">        if (copy_to_user((void __user *)arg, &amp;user_config, sizeof(user_config))) &#123;</span><br><span class="line">            return -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case MY_DEVICE_SET_CONFIG:</span><br><span class="line">        /* arg 被解释为一个指向用户空间内存的指针 */</span><br><span class="line">        struct my_config new_config;</span><br><span class="line">        if (copy_from_user(&amp;new_config, (void __user *)arg, sizeof(new_config))) &#123;</span><br><span class="line">            return -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        // ... 根据 new_config 配置硬件 ...</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        return -ENOTTY; // 未知的命令</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; // 成功</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .unlocked_ioctl = my_ioctl,</span><br><span class="line">    // ... 其他操作 ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="进程、文件描述符、file、inode、设备号关系"><a href="#进程、文件描述符、file、inode、设备号关系" class="headerlink" title="进程、文件描述符、file、inode、设备号关系"></a>进程、文件描述符、file、inode、设备号关系</h2><h3 id="进程与文件描述符"><a href="#进程与文件描述符" class="headerlink" title="进程与文件描述符"></a>进程与文件描述符</h3><ol>
<li>isof 可知某一个文件被哪些进程打开</li>
<li>&#x2F;proc&#x2F;pid&#x2F;fd&#x2F; 可知一个进程打开了哪些文件</li>
</ol>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250924153858412.png" alt="image-20250924153858412"></p>
<p>file存放动态信息，与fd一一对应</p>
<p>关系图如下：</p>
<p>当使用<code>fd0=open(&quot;/dev/com0&quot;,O_RDWR);</code></p>
<ul>
<li>当应用程序调用 <code>open(&quot;/dev/com0&quot;)</code>时，VFS 会找到 <code>/dev/com0</code>对应的 <code>inode</code>。<code>inode</code>中包含了该设备的主次设备号（如 <code>237:0</code>）。</li>
<li>成功打开后，内核会创建一个 <code>struct file</code>对象，其中包含非常重要的 <code>f_op</code>指针，该指针会指向驱动层提供的 <code>file_operations</code>结构体。后续的 <code>read</code>, <code>write</code>等调用，VFS 都会通过这个指针来调用驱动提供的具体函数。</li>
</ul>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250924154709374.png" alt="image-20250924154709374"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static ssize_t led_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">	printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* write(fd, &amp;val, 1); */</span><br><span class="line">static ssize_t led_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line">	char status;</span><br><span class="line">	struct inode *inode = file_inode(file);</span><br><span class="line">	int minor = iminor(inode);</span><br><span class="line">	</span><br><span class="line">	printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	err = copy_from_user(&amp;status, buf, 1);</span><br><span class="line"></span><br><span class="line">	/* 根据次设备号和status控制LED */</span><br><span class="line">	p_led_opr-&gt;ctl(minor, status);</span><br><span class="line">	</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_drv_open (struct inode *node, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	int minor = iminor(node);</span><br><span class="line">	</span><br><span class="line">	printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	/* 根据次设备号初始化LED */</span><br><span class="line">	p_led_opr-&gt;init(minor);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int led_drv_close (struct inode *node, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上述代码中：open close传的是inode和file,但是read,write 只传了file,下一节会用到。</p>
<h2 id="如何支持多个次设备"><a href="#如何支持多个次设备" class="headerlink" title="如何支持多个次设备"></a>如何支持多个次设备</h2><p>open（inode,file） read(file)，对于设备号,inode是储存了的，但是file并没有，如何才能让read ,write找到正确的设备呢？</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250925110452126.png" alt="image-20250925110452126"></p>
<p>open的时候会把inode放进private_data 里，以后的read,write就可以找到设备号</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250925113112701.png" alt="image-20250925113112701"></p>
<p><strong><code>private_data</code>(私有数据指针) - 图中重点突出部分</strong></p>
<ul>
<li><p><strong>作用</strong>：这是一个 <code>void *</code>类型的指针。它就像是内核为驱动开发者预留的一个“万能挂钩”，其生命周期与 <code>struct file</code>绑定（即从 <code>open</code>到 <code>close</code>）。</p>
</li>
<li><p><strong><code>private_data</code>只能存一个指针</strong>，因此如果设计到多个次设备，尽量定义一个dev结构体，包含每个设备的基本信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct xxx_dev &#123;</span><br><span class="line">    /* 1. 内核核心结构体 (必选) */</span><br><span class="line">    struct cdev cdev;           // 字符设备内核对象 (实现 container_of 的关键)</span><br><span class="line">    struct device *device;      // 设备节点对象 (用于 device_create 创建 /dev/xxx)</span><br><span class="line">    dev_t dev_id;               // 设备号 (主设备号 + 次设备号)</span><br><span class="line">    int major;                  // 主设备号 (方便调试打印)</span><br><span class="line">    int id;                     // 自定义的设备 ID (0, 1, 2...)</span><br><span class="line"></span><br><span class="line">    /* 2. 并发控制 (必选) */</span><br><span class="line">    struct mutex mutex_lock;    // 互斥锁：保护长临界区 (如 read/write 里的 buffer)</span><br><span class="line">    spinlock_t spin_lock;       // 自旋锁：保护短临界区 (如中断里的状态位修改)</span><br><span class="line">    atomic_t available;         // 原子变量：用于实现“独占访问” (一次只能被一个进程打开)</span><br><span class="line"></span><br><span class="line">    /* 3. 数据缓冲区 (业务核心) */</span><br><span class="line">    unsigned char *buffer;      // 动态分配的缓冲区指针 (kmalloc)</span><br><span class="line">    int buf_len;                // 缓冲区大小</span><br><span class="line">    int current_len;            // 当前已存数据的长度</span><br><span class="line">    </span><br><span class="line">    /* 4. 硬件资源映射 (硬件驱动专用) */</span><br><span class="line">    void __iomem *base_addr;    // 虚拟地址基地址 (ioremap 后的地址)</span><br><span class="line">    void __iomem *data_reg;     // 数据寄存器地址</span><br><span class="line">    void __iomem *ctrl_reg;     // 控制寄存器地址</span><br><span class="line">    int irq_num;                // 中断号</span><br><span class="line">    int gpio_pin;               // GPIO 引脚号</span><br><span class="line"></span><br><span class="line">    /* 5. 同步与阻塞 (进阶) */</span><br><span class="line">    wait_queue_head_t r_wait;   // 读等待队列 (读数据为空时，进程在这里睡觉)</span><br><span class="line">    wait_queue_head_t w_wait;   // 写等待队列 (缓冲区满时，进程在这里睡觉)</span><br><span class="line">    struct fasync_struct *async_queue; // 异步通知结构体 (信号驱动 IO)</span><br><span class="line"></span><br><span class="line">    /* 6. 定时器与工作队列 (进阶) */</span><br><span class="line">    struct timer_list timer;    // 内核定时器 (如按键消抖)</span><br><span class="line">    struct work_struct work;    // 工作队列 (用于中断下半部处理)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>对驱动开发者的意义</strong>：<strong>这是驱动开发中最重要的工具之一</strong>。你可以在 <code>open</code>函数中为其分配内存，存储<strong>本次打开会话</strong>所需的任何数据（如设备状态、缓冲区、锁等）。在 <code>read</code>, <code>write</code>, <code>ioctl</code>, <code>release</code>等其他所有操作函数中，你都可以通过 <code>filp-&gt;private_data</code>来访问这些数据。</p>
</li>
<li><p><strong>优势</strong>：</p>
<ul>
<li><strong>避免全局变量</strong>：完美解决了<strong>多进程并发访问同一设备</strong>时的数据隔离问题。每个打开实例都有自己的 <code>private_data</code>，互不干扰。</li>
<li><strong>传递上下文</strong>：它是你在驱动不同操作函数之间传递信息的标准、安全的通道。</li>
</ul>
</li>
</ul>
<p>实现：</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250926103533467.png" alt="image-20250926103533467"></p>
<p>上面代码有误：dev_fifo_read中copy_to_user应为copy_to_user（buf,&amp;cd-&gt;test,size）</p>
<p>定义：</p>
<ol>
<li><p><strong>定义设备上下文结构体 (<code>struct mydev</code>)</strong>：为每个设备实例创建一个私有数据结构，用于存储该设备独有的信息（如寄存器地址 <code>reg</code>、测试值 <code>test</code>或缓冲区、锁等）。</p>
</li>
<li><p><strong>创建设备指针数组 (<code>pmydev[MAX_COM_NUM]</code>)</strong>：创建一个全局指针数组，数组的每个元素将指向一个设备实例的 <code>struct mydev</code>。数组的大小 <code>MAX_COM_NUM</code>决定了该驱动最多能支持多少个设备实例。</p>
</li>
</ol>
<p>初始化：</p>
<ol>
<li><p><strong>分配设备内存</strong>：在模块初始化函数中，使用循环为每个设备实例分配内存 (<code>kmalloc</code>)。</p>
</li>
<li><p><strong>初始化每个设备</strong>：为每个设备实例的独有字段赋值（例如图中将 <code>test</code>字段初始化为其索引值 <code>i</code>）。</p>
</li>
<li><p><strong>注册字符设备</strong>：调用 <code>cdev_init</code>和 <code>cdev_add</code>。<strong>特别注意</strong> <code>cdev_add(&amp;cdev, devno, 2)</code>中的最后一个参数 <code>2</code>，它告知内核这个驱动将管理 <strong>2 个连续的次设备号</strong>（从 <code>devno</code>中的次设备号开始）。</p>
</li>
</ol>
<p>运行：</p>
<ul>
<li><strong><code>dev_fifo_open</code>函数</strong>：这是整个模式的关键。<ol>
<li><strong>识别设备</strong>：通过 <code>MINOR(inode-&gt;i_rdev)</code>提取出所打开设备文件的<strong>次设备号</strong>。例如，打开 <code>/dev/mydevice0</code>次设备号为 0，打开 <code>/dev/mydevice1</code>则为 1。</li>
<li><strong>查找实例</strong>：用次设备号作为索引，去全局数组 <code>pmydev</code>中找到对应的设备实例指针：<code>cd = pmydev[MINOR(inode-&gt;i_rdev)];</code>。</li>
<li><strong>关联上下文</strong>：将找到的设备实例指针 <code>cd</code>存入 <code>file-&gt;private_data</code>。这样，在后续的所有操作函数中，都可以通过这个指针来访问到本次打开操作所对应的那个特定设备实例的数据。</li>
</ol>
</li>
<li><strong><code>dev_fifo_read</code>函数</strong>：展示了如何使用存储的上下文。 <ol>
<li><strong>获取实例</strong>：从 <code>file-&gt;private_data</code>中取出在 <code>open</code>时存储的设备实例指针。</li>
<li><strong>操作特定设备</strong>：现在就可以安全地访问和操作这个特定设备的数据了（例如 <code>cd-&gt;test</code>）。</li>
</ol>
</li>
</ul>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20250926110429674.png" alt="image-20250926110429674"></p>
<p>用完记得kfree</p>
<p>多设备的另一种方法</p>
<p><img src="C:\Users\Huuu\AppData\Roaming\Typora\typora-user-images\image-20251222171659665.png" alt="image-20251222171659665"></p>
<p>当 <code>open(struct inode *inode, ...)</code> 被调用时，参数 <code>inode</code> 里面已经包含了一个指向那个 <code>cdev</code> 的指针（<code>inode-&gt;i_cdev</code>）。</p>
<p><strong>既然我都拿到肚子里的 <code>cdev</code> 指针了，我能不能直接算出整个 <code>my_led_dev</code> 的地址？</strong> 能！用 <code>container_of</code> 宏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/cdev.h&gt;</span><br><span class="line">#include &lt;linux/uaccess.h&gt;</span><br><span class="line">#include &lt;linux/slab.h&gt;     // for kmalloc, kfree</span><br><span class="line">#include &lt;linux/device.h&gt;   // for class_create, device_create</span><br><span class="line"></span><br><span class="line">#define DEVICE_COUNT 2      // 我们要创建 2 个设备</span><br><span class="line">#define DEVICE_NAME &quot;my_smart_led&quot;</span><br><span class="line"></span><br><span class="line">/* 1. 定义“大结构体” (核心差异点)</span><br><span class="line"> * 我们把 cdev 直接嵌入到这个结构体里面，而不是分开定义</span><br><span class="line"> */</span><br><span class="line">struct my_led_dev &#123;</span><br><span class="line">    int id;              // 设备编号</span><br><span class="line">    int status;          // 设备状态</span><br><span class="line">    char name[16];       // 设备名字</span><br><span class="line">    struct cdev cdev;    // 【关键】cdev 是这个结构体的一个成员！</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 为了卸载驱动时能释放内存，我们还是要记一下指针。</span><br><span class="line"> * 但注意：Open 函数里绝对不会用这个数组！仅供 Exit 函数打扫战场用。</span><br><span class="line"> */</span><br><span class="line">static struct my_led_dev *led_instances[DEVICE_COUNT];</span><br><span class="line"></span><br><span class="line">static dev_t dev_base;       // 起始设备号</span><br><span class="line">static struct class *my_class; // 用于自动创建节点</span><br><span class="line"></span><br><span class="line">/* ============================================================</span><br><span class="line"> * 核心函数：Open (见证奇迹的时刻)</span><br><span class="line"> * ============================================================ */</span><br><span class="line">static int driver_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    /* * inode-&gt;i_cdev 指向了什么？</span><br><span class="line">     * 它指向了我们在 Init 函数里 cdev_add 进去的那个 struct cdev 成员。</span><br><span class="line">     * * 我们的目标：找到包含这个 cdev 的那个大结构体 struct my_led_dev</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    // 使用 container_of 宏进行“反推”</span><br><span class="line">    // 参数1: 指针 (胃)</span><br><span class="line">    // 参数2: 大结构体类型 (人)</span><br><span class="line">    // 参数3: 大结构体里成员的名字 (胃在肚子里的名字)</span><br><span class="line">    struct my_led_dev *dev = container_of(inode-&gt;i_cdev, struct my_led_dev, cdev);</span><br><span class="line"></span><br><span class="line">    // 【关键】把找到的大结构体存入 private_data</span><br><span class="line">    file-&gt;private_data = dev;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;[Open] 成功识别设备: %s (ID=%d)\n&quot;, dev-&gt;name, dev-&gt;id);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Write 函数 (和方法1完全一样) */</span><br><span class="line">static ssize_t driver_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    // 直接从 private_data 取出，不需要知道次设备号是几</span><br><span class="line">    struct my_led_dev *dev = (struct my_led_dev *)file-&gt;private_data;</span><br><span class="line">    int val;</span><br><span class="line"></span><br><span class="line">    if (copy_from_user(&amp;val, buf, sizeof(int)))</span><br><span class="line">        return -EFAULT;</span><br><span class="line"></span><br><span class="line">    dev-&gt;status = val;</span><br><span class="line">    printk(KERN_INFO &quot;[Write] 设备 %s 状态更新为: %d\n&quot;, dev-&gt;name, dev-&gt;status);</span><br><span class="line">    </span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct file_operations my_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open  = driver_open,</span><br><span class="line">    .write = driver_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* ============================================================</span><br><span class="line"> * 初始化函数</span><br><span class="line"> * ============================================================ */</span><br><span class="line">static int __init driver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    int ret, i;</span><br><span class="line"></span><br><span class="line">    // 1. 动态申请设备号 (一次申请2个)</span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_base, 0, DEVICE_COUNT, DEVICE_NAME);</span><br><span class="line">    if (ret &lt; 0) return ret;</span><br><span class="line"></span><br><span class="line">    // 创建类 (用于自动创建 /dev 节点)</span><br><span class="line">    my_class = class_create(THIS_MODULE, &quot;my_led_class&quot;);</span><br><span class="line"></span><br><span class="line">    // 2. 循环创建每一个设备实例</span><br><span class="line">    for (i = 0; i &lt; DEVICE_COUNT; i++) &#123;</span><br><span class="line">        // A. 申请内存 (造房子)</span><br><span class="line">        led_instances[i] = kmalloc(sizeof(struct my_led_dev), GFP_KERNEL);</span><br><span class="line">        if (!led_instances[i]) return -ENOMEM;</span><br><span class="line"></span><br><span class="line">        // B. 初始化私有数据</span><br><span class="line">        led_instances[i]-&gt;id = i;</span><br><span class="line">        sprintf(led_instances[i]-&gt;name, &quot;LED_%d&quot;, i);</span><br><span class="line"></span><br><span class="line">        // C. 初始化 cdev (常规)</span><br><span class="line">        cdev_init(&amp;led_instances[i]-&gt;cdev, &amp;my_fops);</span><br><span class="line">        led_instances[i]-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">        // D. 添加到内核 (关键)</span><br><span class="line">        // 注意：这里我们添加的是 led_instances[i]-&gt;cdev 这个成员</span><br><span class="line">        // 当用户 open 时，内核拿到的就是这个成员的地址</span><br><span class="line">        dev_t curr_dev = MKDEV(MAJOR(dev_base), i);</span><br><span class="line">        cdev_add(&amp;led_instances[i]-&gt;cdev, curr_dev, 1);</span><br><span class="line"></span><br><span class="line">        // E. 创建节点 /dev/my_smart_led0 和 /dev/my_smart_led1</span><br><span class="line">        device_create(my_class, NULL, curr_dev, NULL, &quot;%s%d&quot;, DEVICE_NAME, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO &quot;驱动加载完成，生成了 %d 个设备\n&quot;, DEVICE_COUNT);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* ============================================================</span><br><span class="line"> * 退出函数</span><br><span class="line"> * ============================================================ */</span><br><span class="line">static void __exit driver_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    dev_t curr_dev;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; DEVICE_COUNT; i++) &#123;</span><br><span class="line">        curr_dev = MKDEV(MAJOR(dev_base), i);</span><br><span class="line">        </span><br><span class="line">        // 销毁节点</span><br><span class="line">        device_destroy(my_class, curr_dev);</span><br><span class="line">        </span><br><span class="line">        // 删除 cdev</span><br><span class="line">        cdev_del(&amp;led_instances[i]-&gt;cdev);</span><br><span class="line">        </span><br><span class="line">        // 释放内存</span><br><span class="line">        kfree(led_instances[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_destroy(my_class);</span><br><span class="line">    unregister_chrdev_region(dev_base, DEVICE_COUNT);</span><br><span class="line">    printk(KERN_INFO &quot;驱动已卸载\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(driver_init);</span><br><span class="line">module_exit(driver_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>



<h2 id="Linux中的并发机制"><a href="#Linux中的并发机制" class="headerlink" title="Linux中的并发机制"></a>Linux中的并发机制</h2><p>并发：多个执行单元同时进行或多个执行单元微观串行执行，宏观并行执行。</p>
<p>竟态：并发的执行单元对共享资源(硬件资源和软件上的全局变量)的访问而导致的竟态状态。</p>
<p>临界资源：多个进程访问的资源</p>
<p>临界区：多个进程访问的代码段</p>
<ol>
<li><p>并发场合1：单CPU之间进程间的并发。时间片轮转，调度进程。A进程访问打印机时间片用完，OS调度B进程访问打印机。</p>
</li>
<li><p>并发场合2：单cpu上进程和中断之间并发。CPU必须停止当前进程的执行去执行中断，如:进程A访问串口，此时产生中断请求，此时OS必须放弃进程的执行，去执行中断处理函数，进行中断处理</p>
</li>
<li><p>并发场合3：多CPU之间：CPU1访问打印机，CPU2也访问打印机</p>
</li>
<li><p>并发场合4：单CPU上中断之间的并发：中断都有优先级，如果CPU在处理中断时候，来了一个优先级更高的中断，此时CPU就会放弃此次中断处理而去响应优先级的中断如:中断A访问串口，中断B产生，中断B优先级&gt;中断A，CPU会立即响应中断B，而B也要访问串口资源。</p>
</li>
</ol>
<p>Linux并发解决方案：</p>
<p>中断、原子操作、自旋锁、信号量、互斥体</p>
<h2 id="一个有问题的并发控制"><a href="#一个有问题的并发控制" class="headerlink" title="一个有问题的并发控制"></a>一个有问题的并发控制</h2><p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20251009202923970.png" alt="image-20251009202923970"></p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作是指不被打断的操作，即它是最小的执行单位。<br>	最简单的原子操作就是一条条的汇编指令(不包括一些伪指令，伪指令会被汇编器解释成多条汇编指令)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 静态定义并初始化</span><br><span class="line">atomic_t my_counter = ATOMIC_INIT(0); // 初始化为0</span><br><span class="line"></span><br><span class="line">// 动态初始化</span><br><span class="line">atomic_set(&amp;my_counter, 0); // 将原子变量设置为0</span><br><span class="line">int atomic_read(atomic_t *v);        // 读取原子变量的值</span><br><span class="line">void atomic_set(atomic_t *v, int i); // 设置原子变量的值为 i</span><br><span class="line">void atomic_inc(atomic_t *v);        // v = v + 1</span><br><span class="line">void atomic_dec(atomic_t *v);        // v = v - 1</span><br><span class="line"></span><br><span class="line">void atomic_add(int i, atomic_t *v); // v = v + i</span><br><span class="line">void atomic_sub(int i, atomic_t *v); // v = v - i</span><br><span class="line">// 以下函数返回操作后的新值</span><br><span class="line"></span><br><span class="line">int atomic_inc_return(atomic_t *v);    // v = v + 1, 然后返回 v 的新值</span><br><span class="line">int atomic_dec_return(atomic_t *v);    // v = v - 1, 然后返回 v 的新值</span><br><span class="line"></span><br><span class="line">// 以下函数返回一个布尔值，用于检查操作后的结果</span><br><span class="line"></span><br><span class="line">int atomic_inc_and_test(atomic_t *v); // v = v + 1, 然后检查结果是否为0？是则返回1，否则返回0。</span><br><span class="line">int atomic_dec_and_test(atomic_t *v); // v = v - 1, 然后检查结果是否为0？常用于引用计数。</span><br><span class="line"></span><br><span class="line">int atomic_sub_and_test(int i, atomic_t *v); // v = v - i, 然后检查结果是否为0？</span><br></pre></td></tr></table></figure>

<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥概念<br>	信号量是在并行处理环境中对多个处理器访问某个公共资源进行保护的机制，mutex用于互斥操作。<br>	mutex的语义相对于信号量要简单轻便一些，在锁争用激烈的测试场景下，mutex比信号量执行速度更快，可扩展性更好，另外mutex数据结构的定义比信号量小,   </p>
<p>mutex使用注意事项：</p>
<ul>
<li>同一时刻只有一个线程可以持有mutex。</li>
<li>只有锁持有者可以解锁，不能在一个进程中持有mutex，在另外一个进程中释放他。</li>
<li>不允许递归地加锁和解锁。</li>
<li>当进程持有mutex时，进程不可以退出。</li>
<li>mutex必须使用官方API来初始化。mutex可以睡眠，所以不允许在中断处理程序或者中断下半部中使用，例如tasklet、定时器等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">静态定义：DEFINE_MUTEX(name);</span><br><span class="line">动态初始化：mutex_init(&amp;mutex);</span><br><span class="line">加锁：mutex_lock(strct mutex*);</span><br><span class="line">解锁：mutex_unlock(struct mutex*)</span><br><span class="line">尝试获取指定的mutex，成功则返回1，否则锁被获取，返回0：mutex_trylock(struct mutex*)</span><br><span class="line">如果锁已被征用，则返回1，否则返回0：mutex_is_lock(struct mutex*)</span><br><span class="line"></span><br><span class="line">使用实例：</span><br><span class="line">struct mutex mutex;</span><br><span class="line">mutex_init(&amp;mutex);/*定义*/</span><br><span class="line">//加锁</span><br><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">//临界区</span><br><span class="line"></span><br><span class="line">//解锁</span><br><span class="line">mutex_unlock(&amp;mutex)</span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量又称为信号灯它是用来协调不同进程间的数据对象的，而最主要的应用是共享内存方式的进程间通信本质上，信号量是一个计数器，它用来记录对某个资源(如共享内存)的存取状况。</p>
<p>它的核心操作是“等待”（P操作）和“释放”（V操作）。P：如果有一个任务想要获得已经被占用的信号量时，信号量会将其放入一个等待队列然后让其睡眠。<br>	V：当持有信号量的进程将信号释放后，处于等待队列中的一个任务将被唤醒(因为队列中可能不止一个任务)，并让其获得信号量</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20251013100332801.png" alt="image-20251013100332801"></p>
<p><strong>简单总结：</strong></p>
<ul>
<li><p><strong>Mutex</strong>：是“钥匙”，一把钥匙只对应一把锁，谁拿了钥匙谁就得负责还回来。用于<strong>互斥</strong>。</p>
</li>
<li><p><strong>Semaphore</strong>：是“票券”，有N张票，拿到票的人可以进场，出来时把票放回。用于<strong>控制并发数</strong>和<strong>同步</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">#include &lt;linux/semaphore.h&gt;</span><br><span class="line"></span><br><span class="line">struct semaphore sem;</span><br><span class="line">sema_init(&amp;sem,1) %数字表示信号量的值，即进程数</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="PV操作："><a href="#PV操作：" class="headerlink" title="PV操作："></a>PV操作：</h3><h4 id="P-操作-获取信号量"><a href="#P-操作-获取信号量" class="headerlink" title="P 操作 (获取信号量)"></a>P 操作 (获取信号量)</h4><p>P 操作对应 <code>down_*</code>系列函数，用于尝试获取一个信号量。如果信号量计数器大于0，则获取成功并递减；如果等于0，则调用者通常会进入睡眠等待。</p>
<ol>
<li><strong><code>down_interruptible(struct semaphore *sem)</code></strong><ul>
<li><strong>最常用</strong>：尝试获取信号量，如果不可用则进入<strong>可中断睡眠</strong>。</li>
<li><strong>返回值</strong>：成功获取返回 <code>0</code>；如果等待过程被信号（如 Ctrl+C）中断，则返回非零值（通常为 <code>-ERESTARTSYS</code>）。</li>
<li><strong>使用场景</strong>：绝大多数需要睡眠等待的情况。<strong>务必检查返回值</strong>以处理被中断的情况。</li>
</ul>
</li>
<li><strong><code>down_killable(struct semaphore *sem)</code></strong><ul>
<li>与 <code>down_interruptible</code>类似，但只响应<strong>致命信号</strong>。</li>
<li><strong>使用场景</strong>：适用于那些只应被致命信号（如 <code>SIGKILL</code>）终止的等待操作。</li>
</ul>
</li>
<li><strong><code>down_trylock(struct semaphore *sem)</code></strong><ul>
<li><strong>非阻塞</strong>版本：尝试获取信号量，如果立即可用则获取并返回 <code>0</code>；如果不可用则<strong>立即返回非零值</strong>，而不会睡眠。</li>
<li><strong>使用场景</strong>：适用于不能等待或需要实现乐观锁的场景。</li>
</ul>
</li>
<li><strong><code>down_timeout(struct semaphore *sem, long jiffies)</code></strong><ul>
<li><strong>带超时</strong>的等待：尝试获取信号量，如果在指定的 <code>jiffies</code>（内核时间单位）时间内未能获取，则超时返回。</li>
<li><strong>返回值</strong>：成功获取返回 <code>0</code>；超时返回 <code>-ETIME</code>。</li>
<li><strong>使用场景</strong>：避免无限期等待，为操作设置一个最长等待时间。</li>
</ul>
</li>
</ol>
<p><strong>关键点</strong>：所有返回 <code>int</code>的函数都有 <code>__must_check</code>属性，这意味着编译器会警告你没有检查它们的返回值。<strong>这是一个必须遵守的编程规范</strong>，否则会导致难以调试的并发问题。</p>
<h4 id="•-V-操作-释放信号量"><a href="#•-V-操作-释放信号量" class="headerlink" title="• V 操作 (释放信号量)"></a>• V 操作 (释放信号量)</h4><p>V 操作对应 <code>up</code>函数，用于释放一个信号量。</p>
<ul>
<li><strong><code>up(struct semaphore *sem)</code></strong><ul>
<li><strong>作用</strong>：释放信号量，递增其计数器。如果发现有进程在该信号量上睡眠等待，则会唤醒其中一个。</li>
<li><strong>特点</strong>：该函数不会失败，且总是能立即完成。</li>
</ul>
</li>
</ul>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>内核当发生访问资源冲突的时候，可以有两种锁的解决方案选择:一个是原地等待， 一个是挂起当前进程，调度其他进程执行(睡眠)。<br>Spinlock 是内核中提供的一种比较常见的锁机制，自旋锁是“原地等待”的方式解决资源冲突的，即，一个线程获取了一个自旋锁后，另外一个线程期望获取该自旋锁，获取不到，只能够原地“打转”(忙等待)。</p>
<p>优点：</p>
<ul>
<li>自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的;不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。</li>
<li>非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。(线程被阻塞后便进入内核(Linux)调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能)</li>
</ul>
<p>注意事项：</p>
<ul>
<li>进程拥有自旋锁的时候，该cpu上是禁止抢占的</li>
<li>一般用于多cpu之间的资源竞争</li>
<li>由于自旋锁的这个忙等待的特性，注定了它使用场景上的限制 — 自旋锁不应该被长时间的持有(消耗 CPU资源)，一般应用在中断上下文。</li>
</ul>
<p>加锁：spin_lock(&amp;lock);</p>
<p>解锁：spin_unlock(&amp;lock);</p>
<p>使用步骤：</p>
<ol>
<li>我们要访问临界资源需要首先申请自旋锁</li>
<li>获取不到锁就自旋，如果能获得锁就进入临界区</li>
<li>当自旋锁释放后，自旋在这个锁的任务即可获得锁并进入临界区，退出临界区的任务必须释放自旋锁</li>
</ol>
<p>使用实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static spinlock_t lock;</span><br><span class="line">static int flage = 1;% 1表示临界区空闲 0表示被占用</span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line"></span><br><span class="line">static int hello_open(struct inode *inode,struct file *filep)</span><br><span class="line">&#123;</span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	if(flage !=1)</span><br><span class="line">	&#123;</span><br><span class="line">		spin_unlock(&amp;lock);%防止锁一直该进程占用，若是不退出，则会导致死锁</span><br><span class="line">		return -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	flage = 0;</span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">static int hello_release(struct inode *inode,struct file *filep)</span><br><span class="line">&#123;</span><br><span class="line">	spin_lock(&amp;lock);    // 获取锁，保护对 flage 的修改</span><br><span class="line">    flage = 1;           // 标记设备为空闲</span><br><span class="line">    spin_unlock(&amp;lock);  // 释放锁</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有获取锁，必定有释放锁，无论有没有打开成功。</p>
<h2 id="自旋锁-死锁"><a href="#自旋锁-死锁" class="headerlink" title="自旋锁-死锁"></a>自旋锁-死锁</h2><p>自旋锁的死锁是指一个或多个执行单元因为无法获取所需的锁而<strong>永远陷入循环等待</strong>的状态，导致系统局部或全部卡死</p>
<p>死锁的两种情况：</p>
<ul>
<li><p>拥有自旋锁的进程A在内核态阻塞了，（在持有锁的临界区内，进程 A 执行了一个<strong>可能引发阻塞（睡眠）的函数</strong>，例如：</p>
<p>kmalloc(size, GFP_KERNEL);（在内存紧张时可能睡眠）;copy_from_user(…);（在访问用户空间内存时可能触发缺页异常，进而可能导致睡眠）;mutex_lock(…);&#96;（互斥锁会导致睡眠）),进程 A 因此进入睡眠状态，被移出运行队列。内核调度B进程，碰巧B进程也要获得自旋锁，此时B只能自旋转。而，政此时抢占已经关闭，（单核CPU）不会调度A进程了，B永远自旋生死锁。</p>
</li>
<li><p>进程A拥有自旋锁，中断到来（如，<strong>硬件中断</strong>发生（例如，网卡收到数据包、定时器到期等，并且这个中断被分配到了<strong>同一个 CPU</strong> 上处理。CPU 暂停执行进程 A，转而执行相应的<strong>中断处理程序（ISR）</strong>），CPU执行中断函数中断处理函数，中断处理函数需要获得自旋锁，访问共享资源，此时无法获得锁，只能自旋，产生死锁。</p>
</li>
</ul>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20251015210255168.png" alt="image-20251015210255168"></p>
<p><strong>spin_lock_irqsave</strong>做了两件事：</p>
<ol>
<li><p><strong>保存当前中断状态</strong>（Flags）。</p>
</li>
<li><p><strong>关闭本地中断</strong>（Disable Interrupts）。</p>
</li>
<li><p><strong>获取自旋锁</strong>。</p>
<p><strong>结果：</strong> 当你用它拿锁时，中断根本进不来。既然中断进不来，就不会发生“中断抢占持锁进程”的情况，从而彻底根除了上述死锁问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 这种写法是通用的，在哪里用都安全 */</span><br><span class="line">void my_driver_write_data() &#123;</span><br><span class="line">    unsigned long flags; // 定义一个变量存状态，分配在栈上</span><br><span class="line"></span><br><span class="line">    // 1. 保存状态 + 关中断 + 上锁</span><br><span class="line">    spin_lock_irqsave(&amp;my_lock, flags);</span><br><span class="line"></span><br><span class="line">    // ... 临界区 (Critical Section) ...</span><br><span class="line">    // 此时绝对安静，没有中断打扰</span><br><span class="line"></span><br><span class="line">    // 2. 解锁 + 恢复状态</span><br><span class="line">    spin_unlock_irqrestore(&amp;my_lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="同步机制总结"><a href="#同步机制总结" class="headerlink" title="同步机制总结"></a>同步机制总结</h2><p>自旋锁和互斥体使用场合</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20251019151608094.png" alt="image-20251019151608094"></p>
<p>在中断上下文中只能使用自旋锁，而在任务睡眠时只能使用互斥体</p>
<p>自旋锁忙等待，拿不到锁时，CPU 会在一个紧凑的循环中<strong>空转</strong>，不断检查锁是否被释放。这<strong>消耗CPU时间</strong>，但避免了进程切换的开销。</p>
<p>互斥体睡眠等待，拿不到锁时，主动放弃CPU，进入睡眠状态，虽然不消耗CPU时间，但是引入了进程切换的开销</p>
<p>中断上下文是不能睡眠的，所以只能使用自旋锁</p>
<p>持有锁需要睡眠，如果使用自旋锁会导致尝试获取锁的进程一直自旋，占用大量的CPU资源</p>
<h4 id="信号量、互斥体与原子变量"><a href="#信号量、互斥体与原子变量" class="headerlink" title="信号量、互斥体与原子变量"></a>信号量、互斥体与原子变量</h4><p>互斥体和信号量很相似，内核中两者共存会全人混淆。所幸，它们的标准使用方式都有简单规范:除非mutex的某个约束妨碍你使用，否则相比信号量要优先使用mutex。<br>	只有碰到特殊场合(一般是当你写新代码时，很底层代码)才会需要使用信号量。因此建议选mutex。如果发现不能满足其约束条件，且没有其他别的选择时，再考虑选择信号量<br>	原子变量用在简单的变量控制上面</p>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>I&#x2F;O：input与output，针对不同的操作对象，可以分为磁盘I&#x2F;O模型，网络I&#x2F;O模型，内存映射I&#x2F;O模型，Direct I&#x2F;O和数据库I&#x2F;O</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\48e66cab-46db-4319-87f4-d43b3daa59a1.png" alt="48e66cab-46db-4319-87f4-d43b3daa59a1"></p>
<p>由图可见，从系统调用的接口再往下，Linux下的IO栈致大致有三个层次：</p>
<p>文件系统层，以 write(2) 为例，内核拷贝了write(2)参数指定的用户态数据到文件系统Cache中，并适时向下层同步</p>
<p>块层，管理块设备的IO队列，对IO请求进行合并、排序（操作系统课程的IO调度算法）</p>
<p>设备层，通过DMA与内存直接交互，完成数据和具体设备之间的交互</p>
<p>结合这个图，想想Linux系统编程里用到的Buffered IO、mmap(2)、Direct IO。</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\9192e18c-bce0-452d-9bf2-d74db39423fc.png" alt="9192e18c-bce0-452d-9bf2-d74db39423fc"></p>
<h4 id="五种I-O模型"><a href="#五种I-O模型" class="headerlink" title="五种I&#x2F;O模型"></a>五种I&#x2F;O模型</h4><ol>
<li><p>阻塞I&#x2F;O（blocking IO）</p>
<p>指调用者在调用某一个函数后，一直在等待该函数的返回值，线程处于挂起状态。好比你去商场试衣间，里面有人，那你就一直在门外等着。(全程阻塞)</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\63b4e18d-a2f5-4eeb-9f8e-7ae0f3fdc84c.png" alt="63b4e18d-a2f5-4eeb-9f8e-7ae0f3fdc84c"></p>
<p>优点:<br>1.能够及时返回数据，无延迟;2.对内核开发者来说这是省事了;3.阻塞期间不占用系统资源<br>缺点:对用户来说处于等待就要付出性能的代价了</p>
</li>
<li><p>非阻塞I&#x2F;O</p>
<p>指调用者在调用某一个函数后，不等待该函数的返回值，线程继续运行其他程序（执行其他操作或者一直遍历该函数是否返回了值）。好比你要喝水，水还没烧开，你就隔段时间去看一下饮水机，直到水烧开为止。(复制数据时阻塞)</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\63b4e18d-a2f5-4eeb-9f8e-7ae0f3fdc84c.png" alt="63b4e18d-a2f5-4eeb-9f8e-7ae0f3fdc84c"></p>
<p>优点：多任务同时执行</p>
<p>缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。</p>
</li>
<li><p>I&#x2F;O多路复用</p>
<p>I&#x2F;O是指网络I&#x2F;O,多路指多个TCP连接(即socket或者channel）,复用指复用一个或几个线程。意思说一个或一组线程处理多个连接。比如课堂上学生做完了作业就举手，老师就下去检查作业。(对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听，可以同时对多个读&#x2F;写操作的IO函数进行轮询检测，直到有数据可读或可写时，才真正调用IO操作函数。)　类比一个人钓十根鱼竿</p>
<p>这种模型其实和BIO是一模一样的，都是阻塞的，只不过在socket上加了一层代理select，select可以通过监控多个socekt是否有数据，通过这种方式来提高性能。<br>一旦检测到一个或多个文件描述有数据到来，select函数就返回，这时再调用recv函数（这块也是阻塞的），数据从内核空间拷贝到用户空间，recv函数返回。</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\7528e759-41e4-41be-b0a3-43a9ec6aab32.png" alt="7528e759-41e4-41be-b0a3-43a9ec6aab32"></p>
</li>
<li><p>信号驱动I&#x2F;O</p>
<p>在用户态程序安装SIGIO信号处理函数（用sigaction函数或者signal函数来安装自定义的信号处理函数），即recv函数。然后用户态程序可以执行其他操作不会被阻塞。<br>一旦有数据到来，操作系统以信号的方式来通知用户态程序，用户态程序跳转到自定义的信号处理函数。<br>在信号处理函数中调用recv函数，接收数据。数据从内核空间拷贝到用户态空间后，recv函数返回。recv函数不会因为等待数据到来而阻塞。<br>这种方式使异步处理成为可能，信号是异步处理的基础。</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\8a367da6-5024-4f71-aca3-e2b3b8305afa.png" alt="8a367da6-5024-4f71-aca3-e2b3b8305afa"></p>
<h3 id="信号驱动-I-O-和-多路复用-I-O区别"><a href="#信号驱动-I-O-和-多路复用-I-O区别" class="headerlink" title="信号驱动 I&#x2F;O 和 多路复用 I&#x2F;O区别"></a><strong>信号驱动 I&#x2F;O</strong> 和 <strong>多路复用 I&#x2F;O</strong>区别</h3><h3 id="核心区别：通知机制与轮询机制"><a href="#核心区别：通知机制与轮询机制" class="headerlink" title="核心区别：通知机制与轮询机制"></a>核心区别：通知机制与轮询机制</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><strong>信号驱动 I&#x2F;O (Signal-Driven I&#x2F;O)</strong></th>
<th align="left"><strong>多路复用 I&#x2F;O (I&#x2F;O Multiplexing)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>核心机制</strong></td>
<td align="left"><strong>异步通知 (Push 模型)</strong></td>
<td align="left"><strong>同步轮询 (Pull 模型)</strong></td>
</tr>
<tr>
<td align="left"><strong>工作原理</strong></td>
<td align="left">内核在 I&#x2F;O 就绪时<strong>主动发送信号</strong>通知应用程序。</td>
<td align="left">应用程序<strong>主动调用</strong>系统函数 (<code>select</code>, <code>poll</code>, <code>epoll_wait</code>等) <strong>询问</strong>内核哪些 I&#x2F;O 已就绪。</td>
</tr>
<tr>
<td align="left"><strong>主动性</strong></td>
<td align="left"><strong>内核主动</strong></td>
<td align="left"><strong>应用程序主动</strong></td>
</tr>
<tr>
<td align="left"><strong>比喻</strong></td>
<td align="left">快递员（内核）把包裹（I&#x2F;O 就绪）送到你家门口，然后**按门铃（发信号）**通知你。</td>
<td align="left">你（应用程序）**每隔一段时间就打电话（调用系统函数）**给快递公司（内核）问：“我的包裹到了吗？”</td>
</tr>
</tbody></table>
</li>
<li><p>异步I&#x2F;O<br>异步IO的效率是最高的。<br>异步IO通过aio_read函数实现，aio_read提交请求，并递交一个用户态空间下的缓冲区。即使内核中没有数据到来，aio_read函数也立刻返回，应用程序就可以处理其他的事情。<br>当数据到来后，操作系统自动把数据从内核空间拷贝到aio_read函数递交的用户态缓冲区。拷贝完成以信号的方式通知用户态程序，用户态程序拿到数据后就可以执行后续操作。<br>异步 I&#x2F;O 的核心思想是：<strong>应用程序发起一个 I&#x2F;O 操作后，立即返回，不会被阻塞。内核会独立完成整个 I&#x2F;O 操作（例如，将数据从磁盘读取到应用程序的缓冲区），操作完成后，内核会通过某种方式通知应用程序。</strong></p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\4354d6b2-2a72-4b82-b31e-c93b5526df56.png" alt="4354d6b2-2a72-4b82-b31e-c93b5526df56"></p>
</li>
</ol>
<h2 id="等待队列-wait-queue"><a href="#等待队列-wait-queue" class="headerlink" title="等待队列 wait queue"></a>等待队列 wait queue</h2><p> <strong>互斥锁的睡眠功能是通过等待队列实现的！</strong></p>
<p>通过<code> add_wait_queue()</code>来将进程添加到waitqueue，当资源准备好了以后，由资源提供方通过<code>wake_up()</code>函数来唤醒等待的进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义头文件：</span><br><span class="line">#include&lt;linux/wait.h&gt;</span><br><span class="line">定义实例：</span><br><span class="line">// 静态初始化</span><br><span class="line">static DECLARE_WAIT_QUEUE_HEAD(my_wait_queue);</span><br><span class="line"></span><br><span class="line">// 或动态初始化</span><br><span class="line">wait_queue_head_t my_queue;</span><br><span class="line">init_waitqueue_head(&amp;my_queue);</span><br></pre></td></tr></table></figure>

<p>阻塞接口</p>
<p>阻塞接口是Linux驱动开发中“等待-通知”机制的基石。当进程请求的资源（如数据、硬件状态）尚未就绪时，内核不是让CPU空转（忙等待），而是将进程置为睡眠状态，直到条件满足后再将其唤醒。这极大地提高了系统的效率和并发能力。</p>
<table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">适用场景</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>wait_event(wq, condition)</code></strong></td>
<td align="left"><strong>不可中断睡眠</strong>。进程会一直睡眠，直到条件为真，<strong>忽略所有信号</strong>（包括<code>Ctrl+C</code>）。</td>
<td>必须完成的关键任务，不允许被用户中断。例如，对系统稳定性至关重要的硬件初始化。</td>
</tr>
<tr>
<td align="left"><strong><code>wait_event_interruptible(wq, condition)</code></strong></td>
<td align="left"><strong>可中断睡眠</strong>。在睡眠期间，如果进程接收到信号，函数会返回<code>-ERESTARTSYS</code>。</td>
<td><strong>最常用</strong>。用于大多数设备驱动（如读取键盘、鼠标）。允许用户通过信号中断长时间等待，避免进程“卡死”。</td>
</tr>
<tr>
<td align="left"><strong><code>wait_event_timeout(wq, condition, timeout)</code></strong></td>
<td align="left"><strong>带超时的不可中断睡眠</strong>。在指定的时间（<code>jiffies</code>单位）内等待条件为真，超时后无论条件如何都会返回。</td>
<td>需要限制最大等待时间的操作。避免因硬件故障等原因导致无限期等待。</td>
</tr>
</tbody></table>
<p>condition为条件表达式，当wake up后，ccondition为真时，唤醒阻塞进程，为假时，继续睡眠</p>
<p><strong>关键点</strong>：<strong>每次被唤醒后都会重新检查条件</strong>。这是因为一次唤醒（<code>wake_up</code>）可能会唤醒队列中的多个进程，但资源可能只满足其中一个进程的条件。</p>
<p>解除阻塞接口</p>
<table>
<thead>
<tr>
<th align="left">睡眠函数</th>
<th align="left">唤醒函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>wait_event</code></td>
<td align="left"><code>wake_up</code></td>
<td align="left">唤醒所有在等待队列上的进程（不可中断和可中断的都会唤醒）。</td>
</tr>
<tr>
<td align="left"><code>wait_event_interruptible</code></td>
<td align="left"><code>wake_up_interruptible</code></td>
<td align="left"><strong>只唤醒</strong>处于可中断睡眠的进程。这是最常用的组合。</td>
</tr>
</tbody></table>
<p>例子：以字符设备为例，在没有数据的时候，在read函数中实现读阻塞，当向内核写入数据时，则唤醒阻塞在该等待队列的所有任务</p>
<h2 id="字符设备poll方法实现"><a href="#字符设备poll方法实现" class="headerlink" title="字符设备poll方法实现"></a>字符设备poll方法实现</h2><p>多路复用机制Select,poll,epoll</p>
<p>I&#x2F;O多路复用就是通过一种机制个进程可以监视多人描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，能够通知程序进行相应的读写操作。</p>
<p>Select，poll和epol是Linux API提供的I&#x2F;O复用方式</p>
<p>重点学习poll</p>
<p>常用事件标志：</p>
<table>
<thead>
<tr>
<th><strong>POLLIN</strong>****</th>
<th>数据可读</th>
<th>普通数据或优先数据可读</th>
</tr>
</thead>
<tbody><tr>
<td><strong>POLLOUT</strong>****</td>
<td>数据可写</td>
<td>可以无阻塞地写入数据</td>
</tr>
</tbody></table>
<p>.poll方法实现</p>
<p>在linux内核源码里，有这样的用法例子</p>
<p>.poll是 struct file_operations中的一个函数指针，简单来说：驱动层的 .poll是应答机制。用户空间问：”这个设备现在能读吗？能写吗？”，你的驱动通过 .poll方法来回答。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\#include &lt;linux/poll.h&gt;</span><br><span class="line"></span><br><span class="line">static struct file_operations my_fops = &#123;</span><br><span class="line">  .owner = THIS_MODULE,</span><br><span class="line">  .read = my_read,</span><br><span class="line">  .write = my_write,</span><br><span class="line">  .poll = my_poll, *//* *关键：实现 poll 机制*</span><br><span class="line">  .open = my_open,</span><br><span class="line">  .release = my_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Poll方法原型：</p>
<p>**unsigned int (*poll) (struct file <em>filp, struct poll_table_struct <em>wait);</em></em></p>
<p><strong>参数1: struct file *filp</strong></p>
<p><strong><strong><strong>作用</strong></strong></strong>：指向内核中代表已打开文件的file结构体的指针。</p>
<p><strong>参数2: struct poll_table_struct *wait</strong></p>
<p><strong><strong><strong>作用</strong></strong></strong>：这是<strong><strong><strong>内核传递的”注册工具”</strong></strong></strong>，驱动用它来告诉内核：”当我的设备状态变化时，应该通过哪个等待队列来唤醒进程。”</p>
<p>**void poll_wait(struct file *filp, wait_queue_head_t <em>wait_address, poll_table <em>p);</em></em></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>filp</code></strong></td>
<td align="left"><code>struct file *</code></td>
<td align="left">当前打开的文件实例指针</td>
</tr>
<tr>
<td align="left"><strong><code>wait_address</code></strong></td>
<td align="left"><code>wait_queue_head_t *</code></td>
<td align="left"><strong>驱动定义的等待队列</strong>（核心参数）</td>
</tr>
<tr>
<td align="left"><strong><code>p</code></strong></td>
<td align="left"><code>poll_table *</code></td>
<td align="left">内核传递的 <code>poll_table</code>结构（来自 <code>.poll</code>方法的参数）</td>
</tr>
</tbody></table>
<p>作用：<strong>注册机制</strong>–告诉内核——“如果当前没有数据，当数据就绪时，请到 wait_address这个等待队列中唤醒等待的进程。</p>
<h4 id="如何实现poll方法？"><a href="#如何实现poll方法？" class="headerlink" title="如何实现poll方法？"></a>如何实现poll方法？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">static unsigned int my_poll(struct file *filp, struct poll_table_struct *wait)</span><br><span class="line">&#123;</span><br><span class="line">    struct my_device *dev = filp-&gt;private_data;</span><br><span class="line">    unsigned int mask = 0;</span><br><span class="line">    </span><br><span class="line">    printk(KERN_INFO &quot;mypoll: .poll() method called\n&quot;);</span><br><span class="line">    </span><br><span class="line">    // 必须调用 poll_wait 注册等待队列（对应图片中的 poll_wait 函数）</span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;read_queue, wait);</span><br><span class="line">    poll_wait(filp, &amp;dev-&gt;write_queue, wait);</span><br><span class="line">    </span><br><span class="line">    mutex_lock(&amp;dev-&gt;lock);</span><br><span class="line">    </span><br><span class="line">    // 检查可读条件：缓冲区中有数据</span><br><span class="line">    if (dev-&gt;data_len &gt; 0) &#123;</span><br><span class="line">        mask |= POLLIN | POLLRDNORM;  // 设置可读事件标志</span><br><span class="line">        printk(KERN_INFO &quot;mypoll: data available, setting POLLIN\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 检查可写条件：缓冲区还有空间</span><br><span class="line">    if (dev-&gt;data_len &lt; BUFFER_SIZE) &#123;</span><br><span class="line">        mask |= POLLOUT | POLLWRNORM; // 设置可写事件标志</span><br><span class="line">        printk(KERN_INFO &quot;mypoll: space available, setting POLLOUT\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">    </span><br><span class="line">    printk(KERN_INFO &quot;mypoll: returning event mask=0x%x\n&quot;, mask);</span><br><span class="line">    return mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// READ方法实现（与poll配合）</span><br><span class="line">static ssize_t my_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)</span><br><span class="line">&#123;</span><br><span class="line">    struct my_device *dev = filp-&gt;private_data;</span><br><span class="line">    ssize_t retval = 0;</span><br><span class="line">    size_t to_read;</span><br><span class="line">    </span><br><span class="line">    printk(KERN_INFO &quot;mypoll: read() called, count=%zu\n&quot;, count);</span><br><span class="line">    </span><br><span class="line">    // 等待数据可读（阻塞）</span><br><span class="line">    if (wait_event_interruptible(dev-&gt;read_queue, (dev-&gt;data_len &gt; 0))) &#123;</span><br><span class="line">        return -ERESTARTSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mutex_lock(&amp;dev-&gt;lock);</span><br><span class="line">    </span><br><span class="line">    if (dev-&gt;data_len &gt; 0) &#123;</span><br><span class="line">        // 计算可读取的数据量</span><br><span class="line">        to_read = min(count, dev-&gt;data_len);</span><br><span class="line">        </span><br><span class="line">        // 从内核缓冲区拷贝到用户空间</span><br><span class="line">        if (copy_to_user(buf, dev-&gt;buffer + dev-&gt;read_pos, to_read)) &#123;</span><br><span class="line">            retval = -EFAULT;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 更新缓冲区状态</span><br><span class="line">        dev-&gt;read_pos = (dev-&gt;read_pos + to_read) % BUFFER_SIZE;</span><br><span class="line">        dev-&gt;data_len -= to_read;</span><br><span class="line">        retval = to_read;</span><br><span class="line">        </span><br><span class="line">        printk(KERN_INFO &quot;mypoll: read %zu bytes, remaining %zu\n&quot;, </span><br><span class="line">               to_read, dev-&gt;data_len);</span><br><span class="line">        </span><br><span class="line">        // 数据被读取，可能有空间可写了，唤醒写等待者</span><br><span class="line">        wake_up_interruptible(&amp;dev-&gt;write_queue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="信号驱动IO-SIGIO"><a href="#信号驱动IO-SIGIO" class="headerlink" title="信号驱动IO-SIGIO"></a>信号驱动IO-SIGIO</h2><p>linux命令<code> kill -l</code>可以查看信号</p>
<p>SIGIO 是 Linux 系统中用于<strong>异步 I&#x2F;O 通知</strong>的信号（Signal 29）。它允许内核在文件描述符准备好 I&#x2F;O 操作时通知进程，而无需进程主动轮询。</p>
<table>
<thead>
<tr>
<th align="left">模型</th>
<th align="left">工作方式</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>阻塞 I&#x2F;O</strong></td>
<td align="left">进程睡眠等待 I&#x2F;O 完成</td>
<td align="left">简单</td>
<td align="left">无法处理并发</td>
</tr>
<tr>
<td align="left"><strong>轮询 (poll&#x2F;select)</strong></td>
<td align="left">主动查询多个描述符</td>
<td align="left">支持多路复用</td>
<td align="left">CPU 占用高</td>
</tr>
<tr>
<td align="left"><strong>SIGIO</strong></td>
<td align="left">内核主动通知进程</td>
<td align="left">实时响应，低延迟</td>
<td align="left">编程复杂，信号处理受限</td>
</tr>
</tbody></table>
<p>接收到信号以后有三种操作：忽略、捕获、默认<br>	忽略：接收到信号后不做任何反应。<br>	捕获：用自定义的信号处理函数来执行特定的动作。<br>	默认：接收到信号后按系统默认的行为处理该信号。这是多数应用采取的处理方式。</p>
<p>信号注册</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br></pre></td></tr></table></figure>

<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20251027142230040.png" alt="image-20251027142230040"></p>
<p>.fasync方法是字符设备的一种操作方法，放在file_operation里，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// .fasync 方法实现</span><br><span class="line">static int my_fasync(int fd, struct file *filp, int on)</span><br><span class="line">&#123;</span><br><span class="line">    struct my_device *dev = filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    // 核心：使用内核辅助函数 fasync_helper</span><br><span class="line">    int retval = fasync_helper(fd, filp, on, &amp;dev-&gt;async_queue);</span><br><span class="line"></span><br><span class="line">    if (retval &lt; 0)</span><br><span class="line">        return retval;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//发送信号 内核向用户空间发送SIGNO，图中第三步</span><br><span class="line">  kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN);</span><br></pre></td></tr></table></figure>

<p>用户层应用程序代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void func(int signo)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;signo= %d\n&quot;,signo);</span><br><span class="line">	read(fd,buff,sizeof(buff));</span><br><span class="line">	printf(&quot;buff=%s\n&quot;,buff);</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	int flage;</span><br><span class="line"></span><br><span class="line">	fd = open(&quot;/dev/hellodev&quot;,O_RDWR);</span><br><span class="line">	if(fd&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;open fail \n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fcntl(fd, F_SETOWN, getpid());      // 步骤1：设置接收信号的进程</span><br><span class="line">	flage = fcntl(fd, F_GETFL);         // 步骤2：获取当前文件状态标志</span><br><span class="line">	fcntl(fd, F_SETFL, flage | FASYNC); // 步骤3：添加 FASYNC 标志</span><br><span class="line">	signal(SIGIO, func);                // 步骤4：注册信号处理函数</span><br><span class="line">	while(1);</span><br><span class="line">	 </span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="platform总线基础"><a href="#platform总线基础" class="headerlink" title="platform总线基础"></a>platform总线基础</h2><p>什么是总线？</p>
<p>SOC上：数据总线、地址总线、控制总线，物理总线：USB\I2C,SPI，</p>
<p>Platform 总线是 Linux 内核中一种<strong>虚拟总线</strong>，用于管理片上系统（SoC）中<strong>无物理总线</strong>的外设控制器（如 GPIO、I2C、SPI 控制器等）</p>
<p>内核如何表示总线？</p>
<p>定义bus_type结构体变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type platform_bus_type = &#123;</span><br><span class="line">    .name = &quot;platform&quot;,              // 总线名称</span><br><span class="line">    .dev_groups = platform_dev_groups, // 设备属性组 可不填</span><br><span class="line">    .match = platform_match,         // 设备-驱动匹配函数</span><br><span class="line">    .uevent = platform_uevent,      // 热插拔事件处理 可不填</span><br><span class="line">    .pm = &amp;platform_dev_pm_ops,     // 电源管理操作</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="platform总线三大组件"><a href="#platform总线三大组件" class="headerlink" title="platform总线三大组件"></a>platform总线三大组件</h4><ol>
<li><h3 id="Platform-Device（硬件描述）"><a href="#Platform-Device（硬件描述）" class="headerlink" title="Platform Device（硬件描述）"></a>Platform Device（硬件描述）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device &#123;</span><br><span class="line">    const char  *name;              // 设备名称，用于与驱动匹配</span><br><span class="line">    int     id;                     // 设备ID，用于区分同名设备</span><br><span class="line">    bool        id_auto;            // 是否自动分配ID</span><br><span class="line">    struct device   dev;            // 内嵌的设备基类，继承通用设备属性</span><br><span class="line">    u32      num_resources;         // 资源数量</span><br><span class="line">    struct resource *resource;      // 资源数组指针（内存、中断等）</span><br><span class="line">    const struct platform_device_id *id_entry; // 设备ID表</span><br><span class="line">    struct mfd_cell *mfd_cell;     // MFD（多功能设备）单元指针</span><br><span class="line">    struct pdev_archdata    archdata; // 架构特定数据</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">设备树节点：</span><br><span class="line">leds: leds &#123;</span><br><span class="line">    compatible = &quot;my-company,my-leds&quot;;  // 硬件型号</span><br><span class="line">    reg = &lt;0x10000000 0x1000&gt;;          // 寄存器地址</span><br><span class="line">    interrupts = &lt;42 IRQ_TYPE_EDGE_RISING&gt;; // 中断信息</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="Platform-Driver（驱动程序）"><a href="#Platform-Driver（驱动程序）" class="headerlink" title="Platform Driver（驱动程序）"></a>Platform Driver（驱动程序）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct platform_driver &#123;</span><br><span class="line">    int (*probe)(struct platform_device *);     // 探测函数：匹配成功后调用</span><br><span class="line">    int (*remove)(struct platform_device *);    // 移除函数：设备断开时调用</span><br><span class="line">    int (*shutdown)(struct platform_device *);  // 关机函数：系统关机时调用</span><br><span class="line">    int (*suspend)(struct platform_device *, pm_message_t);   // 挂起函数</span><br><span class="line">    int (*resume)(struct platform_device *);     // 恢复函数</span><br><span class="line">    struct device_driver driver;                // 内嵌的驱动基类</span><br><span class="line">    const struct platform_device_id *id_table;  // 支持的设备ID表</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">设备树节点：</span><br><span class="line">static struct platform_driver my_led_driver = &#123;</span><br><span class="line">    .probe = my_led_probe,     // 匹配成功后的回调</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = &quot;my-leds&quot;,     // 直接名称匹配</span><br><span class="line">        .of_match_table = my_led_of_match, // 设备树匹配</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 设备树匹配表（根据compatible属性匹配）</span><br><span class="line">static const struct of_device_id my_led_of_match[] = &#123;</span><br><span class="line">    &#123; .compatible = &quot;my-company,my-leds&quot; &#125;, // 匹配设备树中的硬件</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</li>
<li><h3 id="Platform-Bus（匹配中介）"><a href="#Platform-Bus（匹配中介）" class="headerlink" title="Platform Bus（匹配中介）"></a>Platform Bus（匹配中介）</h3></li>
</ol>
<p>​	自动匹配设备和驱动</p>
<p><img src="C:\D-drive-11703\WorkSpace\Blog\source_posts\从0学Linux驱动\image-20251029155919634.png" alt="image-20251029155919634"></p>
<p>注册：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">platform_device_register(&amp;my_device);</span><br><span class="line">platform_device_register(struct pltform_device *pdev)</span><br></pre></td></tr></table></figure>

<h2 id="Platform进阶"><a href="#Platform进阶" class="headerlink" title="Platform进阶"></a>Platform进阶</h2><p>在struct platform_device中有个resource,用于描述硬件资源的核心数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct resource &#123;</span><br><span class="line">    resource_size_t start;     // 资源起始地址（红色标注）</span><br><span class="line">    resource_size_t end;       // 资源结束地址（红色标注）  </span><br><span class="line">    const char *name;          // 资源名称标识</span><br><span class="line">    unsigned long flags;       // 资源类型标志（绿色标注）</span><br><span class="line">    struct resource *parent, *sibling, *child;  // 资源树管理指针</span><br><span class="line">&#125;;</span><br><span class="line">核心资源类型：flags变量的一些宏定义</span><br><span class="line">#define IORESOURCE_IO      0x00000100  // I/O 端口资源</span><br><span class="line">#define IORESOURCE_MEM     0x00000200  // 内存映射资源（最常用）</span><br><span class="line">#define IORESOURCE_REG     0x00000300  // 寄存器偏移量</span><br><span class="line">#define IORESOURCE_IRQ     0x00000400  // 中断请求资源</span><br><span class="line">#define IORESOURCE_DMA     0x00000800  // DMA 通道资源  </span><br><span class="line">#define IORESOURCE_BUS     0x00001000  // 总线编号资源</span><br></pre></td></tr></table></figure>

<p>宏ARRAY_SIZE（x）可以实现计算数组的大小，可以在定义platform_device时使用：num resources &#x3D;ARRAY SIZE(res)</p>
<p><strong>1. match函数何时被调用到？</strong></p>
<p><strong>2. probe函数何时被调用到</strong></p>
<h2 id="内核定时器"><a href="#内核定时器" class="headerlink" title="内核定时器"></a>内核定时器</h2><p>Linux 内核定时器（timer_list）是内核中用于<strong>延迟执行任务</strong>的核心机制，它允许你在指定的时间（基于jiffies）执行特定的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/timer.h&gt;</span><br><span class="line"></span><br><span class="line">struct timer_list &#123;</span><br><span class="line">    struct hlist_node entry;      // 链表节点</span><br><span class="line">    unsigned long expires;         // 到期时间（jiffies值）</span><br><span class="line">    void (*function)(struct timer_list *); // 超时回调函数</span><br><span class="line">    u32 flags;                     // 标志位</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">定义、初始化定时器：</span><br><span class="line">// 方法1：静态定义（推荐）</span><br><span class="line">static DEFINE_TIMER(my_timer, my_timer_callback);</span><br><span class="line"></span><br><span class="line">// 方法2：动态初始化</span><br><span class="line">struct timer_list my_timer;</span><br><span class="line"></span><br><span class="line">void init_my_timer(void)</span><br><span class="line">&#123;</span><br><span class="line">    timer_setup(&amp;my_timer, my_timer_callback, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">API：</span><br><span class="line">// 初始化定时器（现代方式，替代init_timer）</span><br><span class="line">void timer_setup(struct timer_list *timer, </span><br><span class="line">                 void (*function)(struct timer_list *), </span><br><span class="line">                 unsigned int flags);</span><br><span class="line"></span><br><span class="line">// 添加/修改定时器（设置到期时间）</span><br><span class="line">int mod_timer(struct timer_list *timer, unsigned long expires);</span><br><span class="line"></span><br><span class="line">// 删除定时器（非安全版本）</span><br><span class="line">int del_timer(struct timer_list *timer);</span><br><span class="line"></span><br><span class="line">// 安全删除定时器（等待定时器处理完成）</span><br><span class="line">int del_timer_sync(struct timer_list *timer);</span><br><span class="line"></span><br><span class="line">jiffies值：</span><br><span class="line">jiffies是 Linux 内核中最核心的时间计量单位，它记录了系统启动后经过的定时器中断次数，每次定时器中断，jiffies 值增加 1</span><br><span class="line">// 内核配置的 HZ （频率）值（通常在 .config 中定义）</span><br><span class="line">#define HZ 250        // 常见值：100, 250, 300, 1000</span><br><span class="line">1 秒 = HZ 个 jiffies</span><br><span class="line">1 jiffy = 1/HZ 秒</span><br></pre></td></tr></table></figure>



<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/cdev.h&gt;</span><br><span class="line">#include &lt;linux/uaccess.h&gt;</span><br><span class="line">#include &lt;linux/platform_device.h&gt; // Platform 总线</span><br><span class="line">#include &lt;linux/mutex.h&gt;           // 互斥体</span><br><span class="line">#include &lt;linux/spinlock.h&gt;        // 自旋锁</span><br><span class="line">#include &lt;linux/wait.h&gt;            // 等待队列</span><br><span class="line">#include &lt;linux/poll.h&gt;            // Poll</span><br><span class="line">#include &lt;linux/interrupt.h&gt;       // 中断</span><br><span class="line">#include &lt;linux/device.h&gt;</span><br><span class="line">#include &lt;linux/slab.h&gt;            // kzalloc</span><br><span class="line">#include &lt;linux/io.h&gt;              // ioremap</span><br><span class="line"></span><br><span class="line">#define DRIVER_NAME &quot;my_demo_driver&quot;</span><br><span class="line">#define BUF_SIZE 1024</span><br><span class="line"></span><br><span class="line">/* * 1. 定义“全能”设备结构体 </span><br><span class="line"> * 这是驱动的灵魂，把所有资源打包在一起</span><br><span class="line"> */</span><br><span class="line">struct my_demo_dev &#123;</span><br><span class="line">    /* 内核核心结构 */</span><br><span class="line">    dev_t dev_id;               // 设备号</span><br><span class="line">    struct cdev cdev;           // 字符设备对象</span><br><span class="line">    struct device *device;      // 设备节点对象</span><br><span class="line">    struct class *class;        // 类对象</span><br><span class="line"></span><br><span class="line">    /* 硬件资源 */</span><br><span class="line">    void __iomem *base_addr;    // 寄存器虚拟基地址</span><br><span class="line">    int irq_num;                // 中断号</span><br><span class="line"></span><br><span class="line">    /* 并发与同步 */</span><br><span class="line">    struct mutex mutex_lock;    // 互斥锁：保护 buffer 和长临界区</span><br><span class="line">    spinlock_t spin_lock;       // 自旋锁：保护中断上下文共享数据</span><br><span class="line">    wait_queue_head_t r_wq;     // 读等待队列</span><br><span class="line"></span><br><span class="line">    /* 数据缓冲区 */</span><br><span class="line">    char kbuf[BUF_SIZE];        // 内核缓冲区</span><br><span class="line">    int data_len;               // 当前数据长度</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* * 2. 中断服务程序 (ISR) - 模拟硬件产生数据</span><br><span class="line"> */</span><br><span class="line">static irqreturn_t my_isr_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">    struct my_demo_dev *dev = (struct my_demo_dev *)dev_id;</span><br><span class="line">    </span><br><span class="line">    // 中断里必须用自旋锁，不能睡！</span><br><span class="line">    spin_lock(&amp;dev-&gt;spin_lock);</span><br><span class="line">    </span><br><span class="line">    // 模拟硬件写入数据</span><br><span class="line">    // 注意：实际开发中这里通常是读硬件寄存器</span><br><span class="line">    if (dev-&gt;data_len &lt; BUF_SIZE) &#123;</span><br><span class="line">        dev-&gt;kbuf[dev-&gt;data_len] = &#x27;A&#x27;; // 存入一个字符</span><br><span class="line">        dev-&gt;data_len++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    spin_unlock(&amp;dev-&gt;spin_lock);</span><br><span class="line"></span><br><span class="line">    // 唤醒在 read 里睡觉的进程</span><br><span class="line">    wake_up_interruptible(&amp;dev-&gt;r_wq);</span><br><span class="line"></span><br><span class="line">    return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* * 3. File Operations - Open</span><br><span class="line"> */</span><br><span class="line">static int my_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    // 【核心】通过 container_of 找到我们的大结构体</span><br><span class="line">    struct my_demo_dev *dev = container_of(inode-&gt;i_cdev, struct my_demo_dev, cdev);</span><br><span class="line">    </span><br><span class="line">    // 【核心】存入 private_data，供 read/write 使用</span><br><span class="line">    file-&gt;private_data = dev;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* * 4. File Operations - Read (阻塞 IO)</span><br><span class="line"> */</span><br><span class="line">static ssize_t my_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    struct my_demo_dev *dev = file-&gt;private_data;</span><br><span class="line">    int ret = 0;</span><br><span class="line"></span><br><span class="line">    // A. 阻塞等待：如果没有数据，就睡在等待队列上</span><br><span class="line">    if (wait_event_interruptible(dev-&gt;r_wq, (dev-&gt;data_len &gt; 0))) &#123;</span><br><span class="line">        return -ERESTARTSYS; // 被信号打断</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // B. 有数据了，加互斥锁进行拷贝</span><br><span class="line">    if (mutex_lock_interruptible(&amp;dev-&gt;mutex_lock)) &#123;</span><br><span class="line">        return -ERESTARTSYS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // C. 修正读取长度</span><br><span class="line">    if (count &gt; dev-&gt;data_len)</span><br><span class="line">        count = dev-&gt;data_len;</span><br><span class="line"></span><br><span class="line">    // D. 拷贝到用户空间</span><br><span class="line">    if (copy_to_user(buf, dev-&gt;kbuf, count)) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // E. 模拟消费数据（清空）</span><br><span class="line">    dev-&gt;data_len = 0;</span><br><span class="line">    ret = count;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex_lock); // 别忘了解锁！</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* * 5. File Operations - Write</span><br><span class="line"> */</span><br><span class="line">static ssize_t my_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">    struct my_demo_dev *dev = file-&gt;private_data;</span><br><span class="line">    int ret = 0;</span><br><span class="line"></span><br><span class="line">    // 加互斥锁</span><br><span class="line">    if (mutex_lock_interruptible(&amp;dev-&gt;mutex_lock))</span><br><span class="line">        return -ERESTARTSYS;</span><br><span class="line"></span><br><span class="line">    if (count &gt; BUF_SIZE) count = BUF_SIZE;</span><br><span class="line"></span><br><span class="line">    // 拷贝用户数据到内核</span><br><span class="line">    if (copy_from_user(dev-&gt;kbuf, buf, count)) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev-&gt;data_len = count;</span><br><span class="line">    ret = count;</span><br><span class="line">    </span><br><span class="line">    // 写完数据，也可以唤醒读进程（如果业务需要）</span><br><span class="line">    wake_up_interruptible(&amp;dev-&gt;r_wq);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex_lock);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* * 6. File Operations - Poll (多路复用)</span><br><span class="line"> */</span><br><span class="line">static __poll_t my_poll(struct file *file, struct poll_table_struct *wait)</span><br><span class="line">&#123;</span><br><span class="line">    struct my_demo_dev *dev = file-&gt;private_data;</span><br><span class="line">    __poll_t mask = 0;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;dev-&gt;mutex_lock);</span><br><span class="line"></span><br><span class="line">    // 1. 挂号 (不阻塞)</span><br><span class="line">    poll_wait(file, &amp;dev-&gt;r_wq, wait);</span><br><span class="line"></span><br><span class="line">    // 2. 查状态</span><br><span class="line">    if (dev-&gt;data_len &gt; 0)</span><br><span class="line">        mask |= POLLIN | POLLRDNORM; // 可读</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex_lock);</span><br><span class="line">    return mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 7. 关闭设备 */</span><br><span class="line">static int my_release(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    // 通常这里不需要做什么，除非有专门的硬件关闭操作</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 绑定 fops */</span><br><span class="line">static const struct file_operations my_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open  = my_open,</span><br><span class="line">    .read  = my_read,</span><br><span class="line">    .write = my_write,</span><br><span class="line">    .poll  = my_poll,</span><br><span class="line">    .release = my_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* * =================================================================</span><br><span class="line"> * 8. Platform Driver Probe (开业大吉：初始化所有资源)</span><br><span class="line"> * =================================================================</span><br><span class="line"> */</span><br><span class="line">static int my_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct my_demo_dev *dev;</span><br><span class="line">    struct resource *res;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    dev_info(&amp;pdev-&gt;dev, &quot;开始 Probe...\n&quot;);</span><br><span class="line"></span><br><span class="line">    /* A. 申请结构体内存 (使用 devm_ 自动管理，卸载时自动释放) */</span><br><span class="line">    dev = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct my_demo_dev), GFP_KERNEL);</span><br><span class="line">    if (!dev) return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    /* B. 初始化锁和等待队列 */</span><br><span class="line">    mutex_init(&amp;dev-&gt;mutex_lock);</span><br><span class="line">    spin_lock_init(&amp;dev-&gt;spin_lock);</span><br><span class="line">    init_waitqueue_head(&amp;dev-&gt;r_wq);</span><br><span class="line"></span><br><span class="line">    /* C. 获取硬件资源 (Platform 特性) */</span><br><span class="line">    // 获取内存资源</span><br><span class="line">    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br><span class="line">    if (res) &#123;</span><br><span class="line">        // 映射寄存器地址</span><br><span class="line">        dev-&gt;base_addr = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">        if (IS_ERR(dev-&gt;base_addr)) return PTR_ERR(dev-&gt;base_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取中断号</span><br><span class="line">    dev-&gt;irq_num = platform_get_irq(pdev, 0);</span><br><span class="line">    if (dev-&gt;irq_num &gt; 0) &#123;</span><br><span class="line">        // 申请中断</span><br><span class="line">        ret = devm_request_irq(&amp;pdev-&gt;dev, dev-&gt;irq_num, my_isr_handler, </span><br><span class="line">                               IRQF_TRIGGER_RISING, DRIVER_NAME, dev);</span><br><span class="line">        if (ret) dev_err(&amp;pdev-&gt;dev, &quot;中断申请失败\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* D. 注册字符设备 (标准流程) */</span><br><span class="line">    // 1. 申请设备号</span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev-&gt;dev_id, 0, 1, DRIVER_NAME);</span><br><span class="line">    if (ret &lt; 0) return ret;</span><br><span class="line"></span><br><span class="line">    // 2. 初始化 cdev</span><br><span class="line">    cdev_init(&amp;dev-&gt;cdev, &amp;my_fops);</span><br><span class="line">    </span><br><span class="line">    // 3. 添加 cdev</span><br><span class="line">    ret = cdev_add(&amp;dev-&gt;cdev, dev-&gt;dev_id, 1);</span><br><span class="line">    if (ret &lt; 0) goto free_devid;</span><br><span class="line"></span><br><span class="line">    /* E. 创建设备节点 (/dev/my_demo_driver) */</span><br><span class="line">    dev-&gt;class = class_create(THIS_MODULE, DRIVER_NAME);</span><br><span class="line">    dev-&gt;device = device_create(dev-&gt;class, NULL, dev-&gt;dev_id, NULL, DRIVER_NAME);</span><br><span class="line"></span><br><span class="line">    /* F. 保存 dev 指针到 pdev，方便 remove 使用 */</span><br><span class="line">    platform_set_drvdata(pdev, dev);</span><br><span class="line"></span><br><span class="line">    dev_info(&amp;pdev-&gt;dev, &quot;驱动初始化完成！\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">free_devid:</span><br><span class="line">    unregister_chrdev_region(dev-&gt;dev_id, 1);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* * 9. Platform Driver Remove (关门歇业：清理资源)</span><br><span class="line"> * 注意：使用了 devm_ 的资源 (内存, ioremap, irq) 会自动释放，不需要手动清理</span><br><span class="line"> */</span><br><span class="line">static int my_remove(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct my_demo_dev *dev = platform_get_drvdata(pdev);</span><br><span class="line"></span><br><span class="line">    // 销毁节点</span><br><span class="line">    device_destroy(dev-&gt;class, dev-&gt;dev_id);</span><br><span class="line">    class_destroy(dev-&gt;class);</span><br><span class="line"></span><br><span class="line">    // 删除 cdev</span><br><span class="line">    cdev_del(&amp;dev-&gt;cdev);</span><br><span class="line">    </span><br><span class="line">    // 释放设备号</span><br><span class="line">    unregister_chrdev_region(dev-&gt;dev_id, 1);</span><br><span class="line"></span><br><span class="line">    dev_info(&amp;pdev-&gt;dev, &quot;驱动已卸载\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 10. 匹配表 (对应设备树中的 compatible) */</span><br><span class="line">static const struct of_device_id my_match_table[] = &#123;</span><br><span class="line">    &#123; .compatible = &quot;my_company,my_demo_device&quot; &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 11. 驱动结构体 */</span><br><span class="line">static struct platform_driver my_driver = &#123;</span><br><span class="line">    .probe = my_probe,</span><br><span class="line">    .remove = my_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = DRIVER_NAME,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .of_match_table = my_match_table,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 12. 模块入口 */</span><br><span class="line">module_platform_driver(my_driver); // 这是一个宏，替你写了 module_init/exit</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;Gemini&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;A Complete Linux Platform Driver Framework&quot;);</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">huzayn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/12/25/%E4%BB%8E0%E5%AD%A6Linux%E9%A9%B1%E5%8A%A8/">http://example.com/2025/12/25/%E4%BB%8E0%E5%AD%A6Linux%E9%A9%B1%E5%8A%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">huzayn's blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/logo.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/25/test/" title="test"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">test</div></div><div class="info-2"><div class="info-item-1">测试图片  </div></div></div></a><a class="pagination-related" href="/2025/12/25/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">huzayn</div><div class="author-info-description">抱最好的希望，做最坏的打算</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Firegooder"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">----</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8Flinux%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">嵌入式linux驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HELLOWORLD%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99"><span class="toc-number">1.1.</span> <span class="toc-text">HELLOWORLD驱动编写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8ubantu%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%B7%91%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">在ubantu虚拟机中跑驱动程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F-%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.</span> <span class="toc-text">LED驱动程序(驱动设计思想)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA"><span class="toc-number">1.3.</span> <span class="toc-text">符号导出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KERN-SON"><span class="toc-number">1.3.1.</span> <span class="toc-text">KERN_SON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%AF%BC%E5%87%BA-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">符号导出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%BC%A0%E5%8F%82"><span class="toc-number">1.4.</span> <span class="toc-text">模块传参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E6%9D%83%E9%99%90%E5%80%BC%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">其他常见权限值示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sysfs"><span class="toc-number">1.4.2.</span> <span class="toc-text">sysfs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">1.5.</span> <span class="toc-text">字符设备号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%9E%B6%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">字符设备架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C"><span class="toc-number">1.6.1.</span> <span class="toc-text">字符设备注册</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E2%80%93%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">字符设备注册–更简单的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87ioctl%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.</span> <span class="toc-text">字符设备ioctl接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81file%E3%80%81inode%E3%80%81%E8%AE%BE%E5%A4%87%E5%8F%B7%E5%85%B3%E7%B3%BB"><span class="toc-number">1.9.</span> <span class="toc-text">进程、文件描述符、file、inode、设备号关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.9.1.</span> <span class="toc-text">进程与文件描述符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%A4%9A%E4%B8%AA%E6%AC%A1%E8%AE%BE%E5%A4%87"><span class="toc-number">1.10.</span> <span class="toc-text">如何支持多个次设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">1.11.</span> <span class="toc-text">Linux中的并发机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%9C%89%E9%97%AE%E9%A2%98%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.12.</span> <span class="toc-text">一个有问题的并发控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.13.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.14.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.15.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PV%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">1.15.1.</span> <span class="toc-text">PV操作：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#P-%E6%93%8D%E4%BD%9C-%E8%8E%B7%E5%8F%96%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.15.1.1.</span> <span class="toc-text">P 操作 (获取信号量)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%A2-V-%E6%93%8D%E4%BD%9C-%E9%87%8A%E6%94%BE%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.15.1.2.</span> <span class="toc-text">• V 操作 (释放信号量)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.16.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-%E6%AD%BB%E9%94%81"><span class="toc-number">1.17.</span> <span class="toc-text">自旋锁-死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93"><span class="toc-number">1.18.</span> <span class="toc-text">同步机制总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E3%80%81%E4%BA%92%E6%96%A5%E4%BD%93%E4%B8%8E%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="toc-number">1.18.1.</span> <span class="toc-text">信号量、互斥体与原子变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.19.</span> <span class="toc-text">IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.19.1.</span> <span class="toc-text">五种I&#x2F;O模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-I-O-%E5%92%8C-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-I-O%E5%8C%BA%E5%88%AB"><span class="toc-number">1.19.2.</span> <span class="toc-text">信号驱动 I&#x2F;O 和 多路复用 I&#x2F;O区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%EF%BC%9A%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%B8%8E%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6"><span class="toc-number">1.19.3.</span> <span class="toc-text">核心区别：通知机制与轮询机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97-wait-queue"><span class="toc-number">1.20.</span> <span class="toc-text">等待队列 wait queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87poll%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.21.</span> <span class="toc-text">字符设备poll方法实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0poll%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.21.1.</span> <span class="toc-text">如何实现poll方法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO-SIGIO"><span class="toc-number">1.22.</span> <span class="toc-text">信号驱动IO-SIGIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#platform%E6%80%BB%E7%BA%BF%E5%9F%BA%E7%A1%80"><span class="toc-number">1.23.</span> <span class="toc-text">platform总线基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#platform%E6%80%BB%E7%BA%BF%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.23.1.</span> <span class="toc-text">platform总线三大组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Platform-Device%EF%BC%88%E7%A1%AC%E4%BB%B6%E6%8F%8F%E8%BF%B0%EF%BC%89"><span class="toc-number">1.23.2.</span> <span class="toc-text">Platform Device（硬件描述）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Platform-Driver%EF%BC%88%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%EF%BC%89"><span class="toc-number">1.23.3.</span> <span class="toc-text">Platform Driver（驱动程序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Platform-Bus%EF%BC%88%E5%8C%B9%E9%85%8D%E4%B8%AD%E4%BB%8B%EF%BC%89"><span class="toc-number">1.23.4.</span> <span class="toc-text">Platform Bus（匹配中介）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Platform%E8%BF%9B%E9%98%B6"><span class="toc-number">1.24.</span> <span class="toc-text">Platform进阶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.25.</span> <span class="toc-text">内核定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-number">1.26.</span> <span class="toc-text">框架</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/25/test/" title="test">test</a><time datetime="2025-12-25T12:37:48.000Z" title="发表于 2025-12-25 20:37:48">2025-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/25/%E4%BB%8E0%E5%AD%A6Linux%E9%A9%B1%E5%8A%A8/" title="从0学Linux驱动">从0学Linux驱动</a><time datetime="2025-12-25T11:46:26.000Z" title="发表于 2025-12-25 19:46:26">2025-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/25/hello-world/" title="Hello World">Hello World</a><time datetime="2025-12-25T07:32:54.265Z" title="发表于 2025-12-25 15:32:54">2025-12-25</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By huzayn</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-show-text.min.js" data-mobile="false" data-text="zayn" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>